<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>テンプレ</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  /* ★ main背景：入室前/入室後で切替 */
  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('maemain.jpg'); }
  main.joined{ background-image:url('maingazo.jpg'); }

  /* ★ 着席ポップ */
  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  /* ★ ホスト人数選択中：参加者に出す黒ポップ（下固定） */
  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  /* =========================
     ★ 円＋広場を重ねる「テーブルエリア」
     ========================= */
  .table-area{
    position:relative;
    width:min(520px, 92vw);
    height:min(520px, 92vw);
    max-width:520px;
    max-height:520px;
    margin:20px auto 0;
  }

  /* ★ 四角周回の基準 */
  .player-circle{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    border-radius:0;
    box-sizing:border-box;
    border:none;
    z-index:2;
    pointer-events:none;
  }

  /* ★ ガイドの四角枠（不要なら display:none） */
  .player-circle::after{
    content:'';
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:86%;
    height:86%;
    border:2px dashed rgba(0,0,0,.18);
    border-radius:16px;
    background:transparent;
  }

  .player-tag{
    position:absolute;transform:translate(-50%,-50%);
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    line-height:1.1;
    user-select:none;
    cursor:pointer;
    pointer-events:auto;
  }
  .player-tag.me{ background:#111;color:#fff;border-color:#111; }

  /* ★ クリスタルは「ネームタグの上」に固定 */
  .tag-crystal{
    position:absolute;
    left:50%;
    top:-10px;
    transform:translate(-50%,-100%);
    width:18px;height:18px;
    pointer-events:none;
    filter: drop-shadow(0 2px 6px rgba(0,0,0,.20));
  }
  .tag-crystal svg{width:100%;height:100%;display:block;overflow:visible;}

  /* 他プレイヤーのミニカード（ネームタグの下に扇状） */
  .player-tag .mini-hand{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,3px);
    width:60px;height:30px;pointer-events:none;
  }
  .player-tag .mini-card{
    position:absolute;left:50%;top:0;width:16px;height:22px;
    border-radius:4px;border:1px solid #bbb;
    background:linear-gradient(135deg,#e5e7eb,#cbd5f5);
    font-size:10px;display:flex;align-items:center;justify-content:center;
    transform-origin:bottom center;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
  }

  /* ====== 中央「広場」 ====== */
  .plaza-wrap{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    width:min(560px, 92vw);
    z-index:1;
  }
  .plaza{
    position:relative;
    width:100%;
    height:460px;
    border:2px dashed rgba(0,0,0,.18);
    border-radius:16px;
    background:rgba(255,255,255,.55);
    box-shadow:0 10px 24px rgba(0,0,0,.08);
    overflow:hidden;
    touch-action:none;
  }

  /* ★ 広場のカード */
  .field-card{
    position:absolute;
    width:64px;height:96px;
    border-radius:10px;
    border:1px solid rgba(0,0,0,.18);
    background:#fff;
    box-shadow:0 10px 22px rgba(0,0,0,.16);
    display:flex;align-items:center;justify-content:center;
    font-size:24px;font-weight:800;
    transform:translate(-50%,-50%);
    user-select:none;
    touch-action:none;
    cursor:grab;
  }
  .field-card:active{cursor:grabbing;}
  .card-crystal{
    position:absolute;
    right:-10px;
    top:-10px;
    width:18px;height:18px;
    pointer-events:none;
    filter: drop-shadow(0 2px 6px rgba(0,0,0,.22));
  }
  .card-crystal svg{width:100%;height:100%;display:block;overflow:visible;}

  /* ★ 裏向き */
  .field-card.back{
    color:transparent;
    background:
      radial-gradient(circle at 30% 25%, rgba(255,255,255,.5), rgba(255,255,255,0) 45%),
      repeating-linear-gradient(45deg, rgba(0,0,0,.10) 0 6px, rgba(0,0,0,.04) 6px 12px),
      linear-gradient(180deg, #1f2937, #0b1220);
    border-color: rgba(255,255,255,.18);
  }
  .field-card.back::after{
    content:"BACK";
    position:absolute;left:50%;top:50%;
    transform:translate(-50%,-50%);
    font-size:14px;font-weight:900;
    letter-spacing:.12em;
    color:rgba(255,255,255,.65);
  }

  /* ★ お題カード */
  .topic-card{
    position:absolute;
    left:50%;
    top:16px;
    transform:translateX(-50%);
    width:160px;
    height:52px;
    border-radius:12px;
    border:2px solid rgba(255,255,255,.92);
    background:rgba(80, 180, 255, .92);
    box-shadow:0 14px 28px rgba(0,0,0,.18);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    color:#fff;
    letter-spacing:.06em;
    user-select:none;
    pointer-events:none;
    z-index:5;
  }

  /* 自分の手札表示 */
  .my-hand-wrapper{margin-top:16px;text-align:center;}
  .my-hand-title{display:none;}
  .my-hand{display:flex;justify-content:center;gap:8px;margin-top:6px;min-height:110px;flex-wrap:wrap;}
  .my-card{
    width:64px;height:96px;border-radius:10px;border:1px solid #ddd;background:#fff;
    display:flex;align-items:center;justify-content:center;font-size:24px;font-weight:800;
    box-shadow:0 8px 18px rgba(0,0,0,.14);
    user-select:none;
    touch-action:none;
    cursor:grab;
    position:relative;
  }
  .my-card:active{cursor:grabbing;}
  .my-card .hint{
    position:absolute;left:50%;bottom:-18px;transform:translateX(-50%);
    font-size:11px;opacity:.65;white-space:nowrap;
    pointer-events:none;
  }

  /* ★ 手札ドラッグ中のゴースト */
  .hand-drag-ghost{
    position:fixed;
    width:64px;height:96px;
    border-radius:10px;
    border:1px solid rgba(0,0,0,.18);
    background:#fff;
    box-shadow:0 16px 32px rgba(0,0,0,.22);
    display:flex;align-items:center;justify-content:center;
    font-size:24px;font-weight:800;
    transform:translate(-50%,-50%);
    z-index:9999;
    pointer-events:none;
    opacity:.95;
  }

  /* ★ 追い出し確認 */
  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  /* ★ ホスト用 設定ボタン */
  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  /* ★ 設定ポップ */
  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  /* 詳細情報消す用 */
  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:flex-start;
    min-height:calc(100vh - 60px);
    gap:6px;
  }

  /* ★ 左下「？」 */
  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  /* ★ ヘルプ一覧ポップ */
  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}
  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;
  }
  .role-card{
    width:72px;height:108px;border-radius:10px;border:1px solid #ddd;background:#f8f8f8;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    flex:0 0 auto;
    display:flex;align-items:center;justify-content:center;
    font-size:12px;font-weight:700;color:#444;
  }
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:900;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}

  .toast{
    position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:10px 14px;border-radius:999px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:330;font-weight:700;font-size:13px;
    opacity:0; pointer-events:none;
    transition:opacity .15s ease;
  }
  .toast.show{opacity:1;}
</style>
</head>
<body>

<header>
  <h1>テンプレ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">リンクコピー</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div class="table-area" id="tableArea">
      <div id="playerCircle" class="player-circle"></div>
      <div class="plaza-wrap">
        <div id="plaza" class="plaza" aria-label="広場"></div>
      </div>
    </div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>
      <div id="myHand" class="my-hand"></div>
    </div>
  </div>
</main>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>
<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で全プレイヤーにカードを配布（1〜100を1枚）＋お題カードを表示。<br>
    自分のカードを広場にドラッグすると、全員が動かせるカードになります。<br>
    表にするのは「ダブルクリック」です（ポップ無し）。
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<div id="toast" class="toast">ダブルクリックで表になります</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove, runTransaction
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qOQ2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:298688959395:web:6ac2c3eb214201f2020016",
  measurementId: "G-HPDFTCLR8H"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hands: {},
  crystals: {},
  fieldCards: {},
  room: {},
  roomSeed: null,
  revealStarted: false,
  topic: null
};

const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');
const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');
const plazaEl = document.getElementById('plaza');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const toast = document.getElementById('toast');

const ROLE_HELP = [
  { name: "カード1", text: "ああああ" },
  { name: "カード2", text: "いいいい" },
  { name: "カード3", text: "うううう" },
  { name: "カード4", text: "うううう" },
];

function showToast(msg){
  toast.textContent = msg;
  toast.classList.add('show');
  clearTimeout(showToast._t);
  showToast._t = setTimeout(()=>toast.classList.remove('show'), 1200);
}

function renderHelpList(){
  helpBody.innerHTML = '';
  ROLE_HELP.forEach((r, idx) => {
    const row = document.createElement('div');
    row.className = 'role-row';

    const card = document.createElement('div');
    card.className = 'role-card';
    card.textContent = `CARD ${idx+1}`;

    const desc = document.createElement('div');
    desc.className = 'role-desc';
    desc.innerHTML = `
      <div class="name">${r.name}</div>
      <div class="text">${r.text}</div>
    `;
    row.appendChild(card);
    row.appendChild(desc);
    helpBody.appendChild(row);
  });
}
function openHelp(){ renderHelpList(); helpBackdrop.classList.remove('hidden'); }
function closeHelp(){ helpBackdrop.classList.add('hidden'); }
helpBtn.addEventListener('click', () => { if (joinBox.classList.contains('hidden')) openHelp(); });
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => { if (e.target === helpBackdrop) closeHelp(); });

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;
let latestPlayers = [];

/* =========================
   クリスタル系
   ========================= */
function fnv1a32(str){
  let h = 0x811c9dc5;
  for (let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 0x01000193);
  }
  return h >>> 0;
}
function mulberry32(seed){
  let a = seed >>> 0;
  return function(){
    a |= 0; a = (a + 0x6D2B79F5) | 0;
    let t = Math.imul(a ^ (a >>> 15), 1 | a);
    t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function clamp01(v){ return Math.max(0, Math.min(1, v)); }
function hexToRgb(hex){
  const s = hex.replace('#','').trim();
  const v = s.length===3 ? s.split('').map(c=>c+c).join('') : s;
  const n = parseInt(v, 16);
  return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
}
function rgbToHex({r,g,b}){
  const to = (x)=>x.toString(16).padStart(2,'0');
  return `#${to(r)}${to(g)}${to(b)}`;
}
function mix(c1, c2, t){
  const a = hexToRgb(c1), b = hexToRgb(c2);
  const r = Math.round(a.r + (b.r-a.r)*t);
  const g = Math.round(a.g + (b.g-a.g)*t);
  const b2 = Math.round(a.b + (b.b-a.b)*t);
  return '#' + [r,g,b2].map(x=>x.toString(16).padStart(2,'0')).join('');
}
function hslToRgb(h, s, l){
  s/=100; l/=100;
  const k = n => (n + h/30) % 12;
  const a = s * Math.min(l, 1-l);
  const f = n => l - a * Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n), 1)));
  return { r:Math.round(255*f(0)), g:Math.round(255*f(8)), b:Math.round(255*f(4)) };
}
function paletteFromSeed(seed, n=20){
  const rnd = mulberry32(seed ^ 0xA53C9E37);
  const offset = rnd()*360;
  const sat = 78, light = 55;
  const arr = [];
  for(let i=0;i<n;i++){
    const h = (offset + (360/n)*i) % 360;
    const rgb = hslToRgb(h, sat, light);
    arr.push('#' + [rgb.r,rgb.g,rgb.b].map(x=>x.toString(16).padStart(2,'0')).join(''));
  }
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(rnd()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
  return arr;
}

let svgUid = 0;
function crystalSVG(spec, size=18){
  if(!spec || !spec.color || !spec.seed){
    return `<svg viewBox="0 0 64 64" aria-hidden="true"><circle cx="32" cy="32" r="10" fill="#ddd"/></svg>`;
  }
  const uid = (++svgUid);
  const idBase  = `base_${spec.seed}_${uid}`;
  const idShade = `shade_${spec.seed}_${uid}`;
  const idHi    = `hi_${spec.seed}_${uid}`;

  const base = spec.color;
  const c1 = mix(base, "#ffffff", 0.72);
  const c2 = mix(base, "#ffffff", 0.10);
  const c3 = mix(base, "#000000", 0.62);

  const rnd = mulberry32(spec.seed);
  const cx = 32, cy = 32;
  const ptsN = 8;
  const pts = [];
  for(let i=0;i<ptsN;i++){
    const ang = (-90 + (360/ptsN)*i) * Math.PI/180;
    const rad = 24 + rnd()*8;
    const jx = (rnd()-0.5)*4, jy = (rnd()-0.5)*4;
    const x = cx + Math.cos(ang)*rad + jx;
    const y = cy + Math.sin(ang)*rad + jy;
    pts.push([x,y]);
  }
  const d = `M ${pts.map(p=>`${p[0].toFixed(1)} ${p[1].toFixed(1)}`).join(' L ')} Z`;

  const i1 = 1 + Math.floor(rnd()*2);
  const i2 = i1 + 2;
  const i3 = i2 + 2;
  const p1 = pts[i1%ptsN], p2 = pts[i2%ptsN], p3 = pts[i3%ptsN];
  const mid = [(p2[0]+cx)/2, (p2[1]+cy)/2];
  const shadeD = `M ${p1[0].toFixed(1)} ${p1[1].toFixed(1)} L ${p2[0].toFixed(1)} ${p2[1].toFixed(1)} L ${p3[0].toFixed(1)} ${p3[1].toFixed(1)} L ${mid[0].toFixed(1)} ${mid[1].toFixed(1)} Z`;

  const hx = 18 + rnd()*6;
  const hy = 14 + rnd()*6;
  const hiD = `
    M ${hx.toFixed(1)} ${hy.toFixed(1)}
    C ${(hx-6).toFixed(1)} ${(hy+10).toFixed(1)} ${(hx-2).toFixed(1)} ${(hy+20).toFixed(1)} ${(hx+2).toFixed(1)} ${(hy+26).toFixed(1)}
    C ${(hx+6).toFixed(1)} ${(hy+34).toFixed(1)} ${(hx+3).toFixed(1)} ${(hy+40).toFixed(1)} ${(hx-2).toFixed(1)} ${(hy+44).toFixed(1)}
    C ${(hx-4).toFixed(1)} ${(hy+48).toFixed(1)} ${(hx+2).toFixed(1)} ${(hy+50).toFixed(1)} ${(hx+8).toFixed(1)} ${(hy+48).toFixed(1)}
    C ${(hx+16).toFixed(1)} ${(hy+44).toFixed(1)} ${(hx+14).toFixed(1)} ${(hy+34).toFixed(1)} ${(hx+12).toFixed(1)} ${(hy+26).toFixed(1)}
    C ${(hx+10).toFixed(1)} ${(hy+18).toFixed(1)} ${(hx+14).toFixed(1)} ${(hy+12).toFixed(1)} ${(hx+12).toFixed(1)} ${(hy+8).toFixed(1)}
    C ${(hx+10).toFixed(1)} ${(hy+4).toFixed(1)} ${(hx+4).toFixed(1)} ${(hy+4).toFixed(1)} ${hx.toFixed(1)} ${hy.toFixed(1)} Z
  `;

  return `
  <svg viewBox="0 0 64 64" role="img" aria-hidden="true">
    <defs>
      <linearGradient id="${idBase}" x1="14" y1="8" x2="50" y2="58" gradientUnits="userSpaceOnUse">
        <stop offset="0"   stop-color="${c1}" stop-opacity=".95"/>
        <stop offset=".6"  stop-color="${c2}" stop-opacity=".42"/>
        <stop offset="1"   stop-color="${c3}" stop-opacity=".16"/>
      </linearGradient>
      <linearGradient id="${idShade}" x1="42" y1="18" x2="28" y2="58" gradientUnits="userSpaceOnUse">
        <stop offset="0" stop-color="${c3}" stop-opacity=".20"/>
        <stop offset="1" stop-color="${c3}" stop-opacity="0"/>
      </linearGradient>
      <linearGradient id="${idHi}" x1="22" y1="14" x2="32" y2="46" gradientUnits="userSpaceOnUse">
        <stop offset="0" stop-color="#ffffff" stop-opacity=".78"/>
        <stop offset="1" stop-color="#ffffff" stop-opacity="0"/>
      </linearGradient>
    </defs>

    <path d="${d}"
      fill="url(#${idBase})"
      stroke="${mix(base, "#ffffff", 0.55)}" stroke-opacity=".55" stroke-width="1.6"
      stroke-linejoin="round"/>
    <path d="${shadeD}" fill="url(#${idShade})"/>
    <path d="${hiD}" fill="url(#${idHi})" opacity=".92"/>
  </svg>`;
}

function cryptoUint32(){
  const u = new Uint32Array(1);
  crypto.getRandomValues(u);
  return u[0] >>> 0;
}

async function ensureRoomSeed(){
  if(!state.roomCode) return null;
  const seedRef = ref(db, `rooms/${state.roomCode}/seed`);
  const res = await runTransaction(seedRef, (cur) => {
    if (cur === null || cur === undefined) return cryptoUint32() || 123456789;
    return cur;
  });
  state.roomSeed = (res && res.snapshot) ? (res.snapshot.val() >>> 0) : state.roomSeed;
  return state.roomSeed;
}

async function ensureCrystalForPlayer(playerId){
  if(!state.roomCode) return;
  const seed = state.roomSeed ?? await ensureRoomSeed();
  if(seed == null) return;

  const palette = paletteFromSeed(seed, 20);
  const crystalsRef = ref(db, `rooms/${state.roomCode}/crystals`);

  await runTransaction(crystalsRef, (cur) => {
    cur = cur || {};
    if (cur[playerId]) return cur;

    const used = new Set(
      Object.values(cur)
        .filter(v => v && typeof v === 'object' && v.color)
        .map(v => v.color)
    );
    const color = palette.find(c => !used.has(c)) || palette[0];
    cur[playerId] = { color, seed: fnv1a32(`${seed}:${playerId}`) };
    return cur;
  });
}

/* =========================
   提出人数チェック
   ========================= */
function expectedPlayerIds(){
  return (latestPlayers || []).map(p=>p.id).filter(Boolean);
}
function allSubmitted(){
  const ids = expectedPlayerIds();
  if(!ids.length) return false;
  return ids.every(id => !!state.fieldCards?.[id]);
}

/* =========================
   お題
   ========================= */
const TOPIC_POOL = ["ああ","いい","うう","ええ","おお"];
function pickRandom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function renderTopic(){
  const old = plazaEl.querySelector('.topic-card');
  if(old) old.remove();
  if(!state.topic || !state.topic.text) return;

  const t = document.createElement('div');
  t.className = 'topic-card';
  t.textContent = String(state.topic.text);
  plazaEl.appendChild(t);
}

/* =========================
   広場カード
   ========================= */
let localDraggingFieldId = null;
let fieldDragOffset = {dx:0, dy:0};
let rafPending = false;
let pendingFieldXY = null;

function plazaRect(){ return plazaEl.getBoundingClientRect(); }
function setFieldCardElPos(el, x, y){
  el.style.left = `${(x*100).toFixed(3)}%`;
  el.style.top  = `${(y*100).toFixed(3)}%`;
}

function renderFieldCards(){
  plazaEl.innerHTML = '';
  renderTopic();

  const entries = Object.values(state.fieldCards || {});
  entries.sort((a,b)=>(a?.z||0)-(b?.z||0));

  for(const fc of entries){
    if(!fc) continue;

    const el = document.createElement('div');
    el.className = 'field-card';
    el.dataset.id = fc.ownerId;

    const faceUp = !!fc.faceUp;
    if(faceUp){
      el.textContent = String(fc.value ?? '');
    }else{
      el.textContent = '';
      el.classList.add('back');
    }

    const x = clamp01(Number(fc.x ?? 0.5));
    const y = clamp01(Number(fc.y ?? 0.5));
    setFieldCardElPos(el, x, y);
    el.style.zIndex = String(fc.z ?? 1);

    const spec = state.crystals?.[fc.ownerId];
    const c = document.createElement('div');
    c.className = 'card-crystal';
    c.innerHTML = crystalSVG(spec, 18);
    el.appendChild(c);

    el.addEventListener('pointerdown', (e) => {
      if(!state.roomCode) return;

      localDraggingFieldId = fc.ownerId;

      const r = plazaRect();
      const px = r.left + x * r.width;
      const py = r.top  + y * r.height;
      fieldDragOffset.dx = e.clientX - px;
      fieldDragOffset.dy = e.clientY - py;

      el.setPointerCapture(e.pointerId);
      update(ref(db, `rooms/${state.roomCode}/fieldCards/${fc.ownerId}`), { z: Date.now() });
    });

    el.addEventListener('pointermove', (e) => {
      if(localDraggingFieldId !== fc.ownerId) return;
      const r = plazaRect();
      const nx = clamp01((e.clientX - r.left - fieldDragOffset.dx) / r.width);
      const ny = clamp01((e.clientY - r.top  - fieldDragOffset.dy) / r.height);

      setFieldCardElPos(el, nx, ny);

      pendingFieldXY = { id: fc.ownerId, x: nx, y: ny };
      if(!rafPending){
        rafPending = true;
        requestAnimationFrame(() => {
          rafPending = false;
          if(!pendingFieldXY || !state.roomCode) return;
          const p = pendingFieldXY;
          pendingFieldXY = null;
          update(ref(db, `rooms/${state.roomCode}/fieldCards/${p.id}`), { x: p.x, y: p.y });
        });
      }
    });

    el.addEventListener('pointerup', (e) => {
      if(localDraggingFieldId !== fc.ownerId) return;
      localDraggingFieldId = null;
      try{ el.releasePointerCapture(e.pointerId); }catch{}
    });
    el.addEventListener('pointercancel', () => {
      if(localDraggingFieldId === fc.ownerId) localDraggingFieldId = null;
    });

    el.addEventListener('dblclick', async () => {
      if(!state.roomCode) return;
      if(!allSubmitted()) return;
      if(fc.faceUp) return;
      await revealCard(fc.ownerId);
    });

    plazaEl.appendChild(el);
  }
}

async function revealCard(cardId){
  const cardRef = ref(db, `rooms/${state.roomCode}/fieldCards/${cardId}`);
  await update(ref(db, `rooms/${state.roomCode}`), { revealStarted: true });
  await update(cardRef, { faceUp: true });
}

/* =========================
   手札→広場ドラッグ
   ========================= */
let handDrag = null;

function createHandGhost(value){
  const g = document.createElement('div');
  g.className = 'hand-drag-ghost';
  g.textContent = String(value);
  document.body.appendChild(g);
  return g;
}
function moveHandGhost(e){
  if(!handDrag || !handDrag.ghost) return;
  const cx = e.clientX - handDrag.offX;
  const cy = e.clientY - handDrag.offY;
  handDrag.ghost.style.left = `${cx}px`;
  handDrag.ghost.style.top  = `${cy}px`;
}
function startHandDrag(cardEl, value, e){
  if(!state.roomCode) return;
  const r = cardEl.getBoundingClientRect();
  handDrag = {
    el: cardEl,
    value,
    offX: e.clientX - (r.left + r.width/2),
    offY: e.clientY - (r.top  + r.height/2),
    ghost: createHandGhost(value),
  };
  moveHandGhost(e);
  cardEl.setPointerCapture(e.pointerId);
  cardEl.style.opacity = '0.25';
}
function moveHandDrag(e){
  if(!handDrag) return;
  moveHandGhost(e);
}
async function endHandDrag(e){
  if(!handDrag) return;

  const value = handDrag.value;
  const el = handDrag.el;

  const dropX = e.clientX - handDrag.offX;
  const dropY = e.clientY - handDrag.offY;

  el.style.opacity = '';
  try{ el.releasePointerCapture(e.pointerId); }catch{}

  if(handDrag.ghost) handDrag.ghost.remove();

  const r = plazaRect();
  const inside = (dropX >= r.left && dropX <= r.right && dropY >= r.top && dropY <= r.bottom);

  if(inside && state.roomCode){
    const x = clamp01((dropX - r.left) / r.width);
    const y = clamp01((dropY - r.top ) / r.height);

    const fcRef = ref(db, `rooms/${state.roomCode}/fieldCards/${state.userId}`);

    await Promise.all([
      set(fcRef, {
        ownerId: state.userId,
        value,
        x, y,
        z: Date.now(),
        faceUp: false
      }),
      remove(ref(db, `rooms/${state.roomCode}/hands/${state.userId}`))
    ]);
  }

  handDrag = null;
}

/* =========================
   既存ロジック
   ========================= */
function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');
}

function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    state.revealStarted = !!state.room.revealStarted;

    state.topic = state.room.topic || null;

    if(state.revealStarted) showToast('ダブルクリックで表になります');

    syncSeatUI();
    renderFieldCards();
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
  });
}
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
  });
}
function subscribeCrystals(){
  const cRef = ref(db, `rooms/${state.roomCode}/crystals`);
  onValue(cRef, snap => {
    state.crystals = snap.val() || {};
    renderHands();
  });
}
function subscribeFieldCards(){
  const fRef = ref(db, `rooms/${state.roomCode}/fieldCards`);
  onValue(fRef, snap => {
    state.fieldCards = snap.val() || {};
    renderFieldCards();
    renderHands();
  });
}

function renderMyHand(){
  myHandEl.innerHTML = '';
  const myId = state.userId;
  const handData = state.hands[myId];
  if (!handData || typeof handData.card !== 'number') return;

  const cardEl = document.createElement('div');
  cardEl.className = 'my-card';
  cardEl.textContent = String(handData.card);

  const hint = document.createElement('div');
  hint.className = 'hint';
  hint.textContent = '←広場にドラッグ';
  cardEl.appendChild(hint);

  cardEl.addEventListener('pointerdown', (e) => startHandDrag(cardEl, handData.card, e));
  cardEl.addEventListener('pointermove', (e) => moveHandDrag(e));
  cardEl.addEventListener('pointerup',   (e) => endHandDrag(e));
  cardEl.addEventListener('pointercancel', () => {
    if(handDrag && handDrag.el === cardEl){
      cardEl.style.opacity = '';
      if(handDrag.ghost) handDrag.ghost.remove();
      handDrag = null;
    }
  });

  myHandEl.appendChild(cardEl);
}
function renderHands(){
  renderMyHand();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  renderFieldCards();
}

const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  await ensureRoomSeed();
  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribeCrystals();
  subscribeFieldCards();

  if(state.seatedTable !== null){
    await ensureCrystalForPlayer(state.userId);
  }
  syncSeatUI();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='リンクコピー';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';

      for(let i=2; i<=20; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });

          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');

          await ensureCrystalForPlayer(state.userId);
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 20;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');

        await ensureCrystalForPlayer(state.userId);
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await ensureRoomSeed();
    for(const p of players){
      ensureCrystalForPlayer(p.id);
    }

    await syncSeatUI();
    renderPlayerCircle(players);
  });
}

/* =========================================================
   ★ 要求どおり：
   1) 自分のネームタグは必ず「下辺中央」(rounded-rect周回の bottom center) に固定
   2) それでも「均等に並ぶ」＝全員を等間隔で配置した見え方にする
      -> 全員N人の等間隔 t を作り、そこから
         ・自分のtを「下中央」に来るように全体を回転
         ・最後に自分だけ厳密に下中央へスナップ（数値誤差対策）
   ========================================================= */
function pointOnRoundedRectPerimeter(t, w, h, r){
  r = Math.max(0, Math.min(r, Math.min(w,h)/2));

  const straightW = Math.max(0, w - 2*r);
  const straightH = Math.max(0, h - 2*r);
  const L = 2*(straightW + straightH) + 2*Math.PI*r;

  let d = (t - Math.floor(t)) * L;

  if(d <= straightW){
    return { x: r + d, y: 0 };
  }
  d -= straightW;

  const arcLen = (Math.PI/2)*r;
  if(d <= arcLen){
    const a = (-Math.PI/2) + (d/arcLen)*(Math.PI/2);
    return { x: w - r + Math.cos(a)*r, y: r + Math.sin(a)*r };
  }
  d -= arcLen;

  if(d <= straightH){
    return { x: w, y: r + d };
  }
  d -= straightH;

  if(d <= arcLen){
    const a = (0) + (d/arcLen)*(Math.PI/2);
    return { x: w - r + Math.cos(a)*r, y: h - r + Math.sin(a)*r };
  }
  d -= arcLen;

  if(d <= straightW){
    return { x: (w - r) - d, y: h };
  }
  d -= straightW;

  if(d <= arcLen){
    const a = (Math.PI/2) + (d/arcLen)*(Math.PI/2);
    return { x: r + Math.cos(a)*r, y: h - r + Math.sin(a)*r };
  }
  d -= arcLen;

  if(d <= straightH){
    return { x: 0, y: (h - r) - d };
  }
  d -= straightH;

  const a = (Math.PI) + (Math.min(d, arcLen)/arcLen)*(Math.PI/2);
  return { x: r + Math.cos(a)*r, y: r + Math.sin(a)*r };
}

/* ★ rounded-rect周回で「下辺中央」に来るt（この形状定義では、直線+右下コーナー後に下辺へ入る）
   - ここは固定値でもOKだけど、形が変わっても “下辺中央” を狙えるよう、幾何に依存せず数値指定する。
   - 既存実装の pointOnRoundedRectPerimeter の “下辺” 区間は d が「直線W + 2*arc + 直線H + arc」後。
   - ただし実用上は固定tで十分なので、ここでは視覚的にズレない値を採用。
*/
const ANCHOR_T_BOTTOM_CENTER = 0.50; // ★ 下辺中央（見た目優先の安定値）

function renderPlayerCircle(players){
  playerCircle.innerHTML = '';
  if (!players.length) return;

  // ★ 四角（%空間）
  const rectW = 86;
  const rectH = 86;
  const rectX0 = (100 - rectW)/2;
  const rectY0 = (100 - rectH)/2;

  // ★ 角丸
  const cornerR = 10;

  // ★ 自分を探す
  const meIndex = players.findIndex(p => p.id === state.userId);
  const me = (meIndex >= 0) ? players[meIndex] : null;

  const N = players.length;
  const step = 1 / N;

  // ★ 全員を「等間隔」で並べる基準t（seatIndex順のまま）
  //    tBase[i] = i*step
  // ★ そのうえで「自分」が下辺中央に来るように全体を回転（offsetを足す）
  //    (meIndex * step + offset) % 1 = anchor
  //     -> offset = anchor - meIndex*step
  const anchor = ANCHOR_T_BOTTOM_CENTER;
  const offset = (meIndex >= 0) ? (anchor - meIndex * step) : anchor;

  function placePlayer(p, t, isMe=false){
    const pt = pointOnRoundedRectPerimeter(t, rectW, rectH, cornerR);
    const x = rectX0 + pt.x;
    const y = rectY0 + pt.y;

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (isMe ? ' me' : '');
    tag.textContent = p.name;
    tag.style.left = `${x}%`;
    tag.style.top  = `${y}%`;

    // ★ クリスタル：タグの上（CSSで上配置）
    const spec = state.crystals?.[p.id];
    const crystal = document.createElement('div');
    crystal.className = 'tag-crystal';
    crystal.innerHTML = crystalSVG(spec, 18);
    tag.appendChild(crystal);

    tag.onclick = () => {
      if (p.id === state.userId) return;
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      pendingSeatIndexToSteal = p.seatIndex;
      pendingSeatPlayerIdToSteal = p.id;
      kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
      kickDialog.classList.remove('hidden');
    };

    const handData = state.hands[p.id];
    if (!isMe && handData && typeof handData.card === 'number'){
      const miniHand = document.createElement('div');
      miniHand.className = 'mini-hand';
      const card = document.createElement('div');
      card.className = 'mini-card';
      card.textContent = '';
      miniHand.appendChild(card);
      tag.appendChild(miniHand);
    }

    playerCircle.appendChild(tag);
  }

  // ★ 全員を等間隔に配置（回転込み）
  for(let i=0;i<N;i++){
    const p = players[i];
    const t = (i * step + offset) % 1;
    placePlayer(p, t, p.id === state.userId);
  }

  // ★ 最後に、自分だけ“必ず”下辺中央にスナップ（誤差やmeIndex未検出時の保険）
  if(me){
    // 既に一度描画しているので、該当要素だけ座標を上書き
    const meEl = playerCircle.querySelector('.player-tag.me');
    if(meEl){
      const pt = pointOnRoundedRectPerimeter(anchor, rectW, rectH, cornerR);
      const x = rectX0 + pt.x;
      const y = rectY0 + pt.y;
      meEl.style.left = `${x}%`;
      meEl.style.top  = `${y}%`;
    }
  }
}

kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;
  await ensureCrystalForPlayer(state.userId);

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
  seatPop.classList.add('hidden');
});

/* ★ 配布 & お題 */
async function dealInitialHandsAndTopic(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};

  const playerIds = [];
  for (const seatIndex of Object.keys(tables)) {
    const t = tables[seatIndex];
    if (!t || !t.playerId) continue;
    playerIds.push(t.playerId);
  }
  if(!playerIds.length) return;

  const nums = Array.from({length:100}, (_,i)=>i+1);
  for(let i=nums.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [nums[i], nums[j]] = [nums[j], nums[i]];
  }

  const hands = {};
  playerIds.forEach((pid, idx) => { hands[pid] = { card: nums[idx] }; });

  const topicText = pickRandom(TOPIC_POOL);

  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/hands`), hands),
    remove(ref(db, `rooms/${state.roomCode}/fieldCards`)),
    update(ref(db, `rooms/${state.roomCode}`), {
      revealStarted: false,
      topic: { text: topicText, at: Date.now() }
    })
  ]);
}

hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => { startPop.classList.add('hidden'); });

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  await dealInitialHandsAndTopic();
  startPop.classList.add('hidden');
});

btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/fieldCards`)),
    remove(ref(db, `${base}/crystals`)),
    remove(ref(db, `${base}/seed`)),
    remove(ref(db, `${base}/topic`)),
    update(ref(db, `${base}`), { revealStarted:false })
  ]);

  state.seatedTable = null;
  startPop.classList.add('hidden');
  await syncSeatUI();
});
</script>

</body>
</html>
