<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ITO</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@700;800&family=Fredoka:wght@600;700&display=swap" rel="stylesheet">

<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('itobody.png'); }
  main.joined{ background-image:url('itobody.png'); }

  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:#bfe9ff;border:1px solid rgba(0,0,0,.08);border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;background:rgba(255,255,255,.65);}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  .table-area{
    position:relative;
    width:min(520px, 92vw);
    height:min(520px, 92vw);
    max-width:520px;
    max-height:520px;
    margin:20px auto 0;
  }

  .player-circle{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    border-radius:0;
    box-sizing:border-box;
    border:none;
    z-index:30;
    pointer-events:none;
  }
  .player-circle::after{
    content:'';
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:86%;
    height:86%;
    border:2px dashed rgba(0,0,0,.18);
    border-radius:16px;
    background:transparent;
    display:none;
  }

  .player-tag{
    position:absolute;transform:translate(-50%,-50%);
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    line-height:1.1;
    user-select:none;
    cursor:pointer;
    pointer-events:auto;
    z-index:60;
  }
  .player-tag.me{ background:#111;color:#fff;border-color:#111; }

  .tag-crystal{
    position:absolute;
    left:50%;
    top:-10px;
    transform:translate(-50%,-100%);
    width:18px;height:18px;
    pointer-events:none;
    filter: drop-shadow(0 2px 6px rgba(0,0,0,.20));
    z-index:1;
  }
  .tag-crystal svg{width:100%;height:100%;display:block;overflow:visible;}

  .player-tag .mini-hand{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,3px);
    width:70px;height:30px;pointer-events:none;
  }
  .player-tag .mini-card{
    position:absolute;top:0;width:16px;height:22px;
    border-radius:4px;border:1px solid #bbb;
    background-image:url('itocard.png');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    font-size:10px;display:flex;align-items:center;justify-content:center;
    transform-origin:bottom center;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
  }

  .plaza-wrap{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    width:min(560px, 92vw);
    z-index:10;
    top: calc(50% + 60px);
  }
  .plaza{
    position:relative;
    width:100%;
    height:460px;
    border:2px dashed #000;
    border-radius:16px;
    background-image:
      linear-gradient(rgba(255,255,255,.35), rgba(255,255,255,.35)),
      url('itotable.png');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;

    box-shadow:0 10px 24px rgba(0,0,0,.08);
    overflow:hidden;
    touch-action:none;
    z-index:10;
  }

  .card-num{
    font-family: "Fredoka", "Baloo 2", system-ui, sans-serif;
    font-weight: 800;
    letter-spacing: .02em;
    line-height: 1;
    display:inline-block;
    transform: rotate(var(--rot, 0deg));
    color: var(--ink, #111);
    text-shadow:
      -1px -1px 0 rgba(255,255,255,.95),
       1px -1px 0 rgba(255,255,255,.95),
      -1px  1px 0 rgba(255,255,255,.95),
       1px  1px 0 rgba(255,255,255,.95),
       0   4px 10px var(--numShadow, rgba(0,0,0,.18));
    font-size: 42px;
  }

  .field-card{
    position:absolute;
    width:64px;height:96px;
    border-radius:10px;
    border:1px solid rgba(0,0,0,.18);
    background:#fff;
    box-shadow:0 10px 22px rgba(0,0,0,.16);
    display:flex;align-items:center;justify-content:center;
    font-size:24px;font-weight:800;
    transform:translate(-50%,-50%);
    user-select:none;
    touch-action:none;
    cursor:grab;
    z-index:70;
    overflow:visible;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  .field-card:active{cursor:grabbing;}

  .card-crystal{
    position:absolute;
    right:-6px;
    top:-6px;
    width:18px;height:18px;
    pointer-events:none;
    filter: drop-shadow(0 2px 6px rgba(0,0,0,.22));
    z-index:2;
  }
  .card-crystal svg{width:100%;height:100%;display:block;overflow:visible;}

  .field-card.back{
    color:transparent;
    background-image: url('itocard.png');
    border-color: rgba(0,0,0,.18);
  }
  .field-card.back::after{ content:none; }

  .topic-bar{
    position:absolute;
    left:50%;
    top:16px;
    transform:translateX(-50%);
    display:flex;
    align-items:center;
    gap:10px;
    z-index:90;
    pointer-events:auto;
  }
  .topic-card{
    width:160px;
    height:52px;
    border-radius:12px;
    border:2px solid rgba(255,255,255,.92);
    background:rgba(80, 180, 255, .92);
    box-shadow:0 14px 28px rgba(0,0,0,.18);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    color:#fff;
    letter-spacing:.06em;
    user-select:none;
    pointer-events:auto;
    cursor:pointer;
    flex:0 0 auto;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:clip;
  }
  .topic-ui{
    display:flex;
    align-items:center;
    gap:8px;
  }
  .heart-row{
    display:flex;
    align-items:center;
    gap:6px;
  }
  .heart-btn{
    width:20px;height:20px;
    border:none;
    background:transparent;
    padding:0;
    cursor:pointer;
    display:grid;
    place-items:center;
  }
  .heart-btn svg{width:20px;height:20px;display:block;}

  .deal-stack{
    position:relative;
    width:46px;
    height:30px;
    flex:0 0 auto;
  }
  .deal-card{
    position:absolute;
    top:0;
    width:20px;height:28px;
    border-radius:6px;
    border:1.6px solid #111;
    background-image:url('itocard.png');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    box-shadow:0 4px 10px rgba(0,0,0,.14);
  }
  .deal-plus{
    width:30px;height:30px;
    border-radius:50%;
    border:none;
    background:#111;
    color:#fff;
    font-weight:900;
    font-size:12px;
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    line-height:1;
    user-select:none;
  }
  .deal-plus:active{transform:translateY(1px);}

  .my-hand-wrapper{margin-top:16px;text-align:center; position:relative; z-index:60;}
  .my-hand-title{display:none;}
  .my-hand{display:flex;justify-content:center;gap:8px;margin-top:6px;min-height:110px;flex-wrap:wrap;}
  .my-card{
    width:64px;height:96px;border-radius:10px;border:1px solid #ddd;background:#fff;
    display:flex;align-items:center;justify-content:center;font-size:24px;font-weight:800;
    box-shadow:0 8px 18px rgba(0,0,0,.14);
    user-select:none;
    touch-action:none;
    cursor:grab;
    position:relative;
    z-index:70;
    overflow:hidden;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  .my-card:active{cursor:grabbing;}
  .my-card .hint{
    position:absolute;left:50%;bottom:-18px;transform:translateX(-50%);
    font-size:11px;opacity:.65;white-space:nowrap;
    pointer-events:none;
  }

  /* =========================
     ✅ 数字カード：白枠 + 単色背景
     ========================= */
  .field-card,
  .my-card{
    border:5px solid #fff;
    background-image:none !important;
    background-color: var(--bgSolid, #eee);
    box-shadow:0 10px 22px rgba(0,0,0,.16);
  }
  .field-card::before,
  .my-card::before{
    content:none !important;
  }
  .field-card.back{
    background-image:url('itocard.png') !important;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    background-color:transparent !important;
    border:1px solid rgba(0,0,0,.18) !important;
  }

  .card-note{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:80%;
    height:80%;
    border-radius:10px;
    border:none;
    box-shadow:none;
    background:rgba(255,255,255,.76);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:6px 8px;
    box-sizing:border-box;
    text-align:center;
    font-size:12px;
    font-weight:700;
    color:#000;
    line-height:1.25;
    white-space:pre-wrap;
    word-break:break-word;
    pointer-events:none;
    z-index:3;
  }
  .field-card.back .card-note{
    color:#000;
    background:rgba(255,255,255,.76);
  }
  .field-card.faceup .card-note{
    background:transparent;
    color:#9ca3af;
  }

  .hand-drag-ghost{
    position:fixed;
    width:64px;height:96px;
    border-radius:10px;
    border:5px solid #fff;
    background-image:none !important;
    background-color: var(--bgSolid, #eee) !important;
    box-shadow:0 16px 32px rgba(0,0,0,.22);
    display:flex;align-items:center;justify-content:center;
    font-size:24px;font-weight:800;
    transform:translate(-50%,-50%);
    z-index:9999;
    pointer-events:none;
    opacity:.95;
    overflow:hidden;
  }

  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:flex-start;
    min-height:calc(100vh - 60px);
    gap:6px;
  }

  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}

  /* ✅ ヘルプ内：お題カード 3×10 */
  .topic-grid{
    display:grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap:10px;
  }
  .topic-help-card{
    border-radius:12px;
    border:2px solid rgba(255,255,255,.92);
    box-shadow:0 10px 22px rgba(0,0,0,.14);
    padding:10px 10px;
    min-height:64px;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    font-weight:900;
    letter-spacing:.02em;
    user-select:none;
    cursor:pointer;
    overflow:hidden;
    position:relative;

    /* ✅ 既存のお題カード設定に合わせる（色は変えない） */
    background:rgba(80, 180, 255, .92);
    color:#fff;
  }
  .topic-help-card:active{ transform: translateY(1px); }

  /* 長文でも見えるように */
  .topic-help-card .ttext{
    font-size:13px;
    line-height:1.25;
    display:-webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow:hidden;
    word-break:break-word;
  }

  .toast{display:none !important;}

  .input-backdrop{
    position:fixed; inset:0;
    background:rgba(0,0,0,.35);
    display:flex; align-items:center; justify-content:center;
    z-index:340;
    padding:16px;
  }
  .input-backdrop.hidden{display:none;}
  .input-pop{
    width:min(420px, calc(100% - 0px));
    background:#fff;
    border:1px solid #ddd;
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    padding:14px;
  }
  .input-title{font-weight:900; font-size:14px; margin:0 0 10px;}
  .input-area{
    width:100%;
    min-height:110px;
    resize:none;
    padding:10px 12px;
    border:1px solid #ddd;
    border-radius:12px;
    font-size:16px;
    line-height:1.5;
    box-sizing:border-box;
    outline:none;
  }
  .input-hint{margin-top:10px; font-size:12px; opacity:.7;}

  .player-tag.me{ margin-top: 60px; }
  #myHand{ margin-top: 60px; }
  @media (max-width: 600px){
    .player-tag.me{ margin-top: 110px; }
    #myHand{ margin-top: 110px; }
  }
  input, textarea, select, button{ font-size:16px; }
</style>
</head>
<body>

<header>
  <h1>ITO</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div class="table-area" id="tableArea">
      <div id="playerCircle" class="player-circle"></div>
      <div class="plaza-wrap">
        <div id="plaza" class="plaza" aria-label="広場"></div>
      </div>
    </div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>
      <div id="myHand" class="my-hand"></div>
    </div>
  </div>
</main>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<!-- ✅ 追加：1枚目の公開だけ確認ポップ -->
<div id="revealDialog" class="dialog-backdrop hidden">
  <div class="dialog-box">
    <p id="revealMessage">このカードを表にしますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnRevealNo">いいえ</button>
      <button class="btn primary" id="btnRevealYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>
<button id="helpBtn" class="help-btn" title="お題一覧">？</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="お題一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">お題カード（クリックで変更）</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で全プレイヤーにカードを配布（1〜100）＋お題カードを表示。<br>
    お題カード右の「+1」で配布枚数(1〜3)を変更できます（2→3→1…）。<br>
    自分のカードを広場にドラッグすると、全員が動かせるカードになります。<br>
    ★ 場の自分のカードは「ワンクリック」で書き直し（ドラッグしなかったクリックのみ）<br>
    ★ 公開（表にする）は「ダブルクリック」<br>
    ・最初の1枚目だけ「はい/いいえ」確認ポップ<br>
    ・すでに表が1枚以上あるなら、2枚目以降は即公開
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<div id="inputBackdrop" class="input-backdrop hidden" role="dialog" aria-modal="true" aria-label="入力">
  <div class="input-pop" id="inputPop">
    <p class="input-title" id="inputTitle">カードに書く内容</p>
    <textarea id="inputArea" class="input-area" placeholder="ここに入力…"></textarea>
    <div class="input-hint">ポップ外をクリックすると入力完了</div>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove, runTransaction, push
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyDUP1foVQnitM45do_UtYLkcc9gvgQC-xw",
  authDomain: "timebomb-3b0c7.firebaseapp.com",
  databaseURL: "https://timebomb-3b0c7-default-rtdb.firebaseio.com",
  projectId: "timebomb-3b0c7",
  storageBucket: "timebomb-3b0c7.firebasestorage.app",
  messagingSenderId: "532935786630",
  appId: "1:532935786630:web:ef1f97c862bfaad67d1107",
  measurementId: "G-K8NRR8K64Y"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hands: {},
  crystals: {},
  fieldCards: {},
  room: {},
  roomSeed: null,
  revealStarted: false,
  topic: null,
  notes: {},
  cardStyle: {}
};

const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');
const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');
const plazaEl = document.getElementById('plaza');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const revealDialog = document.getElementById('revealDialog');
const revealMessage = document.getElementById('revealMessage');
const btnRevealYes = document.getElementById('btnRevealYes');
const btnRevealNo  = document.getElementById('btnRevealNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const inputBackdrop = document.getElementById('inputBackdrop');
const inputPop = document.getElementById('inputPop');
const inputTitle = document.getElementById('inputTitle');
const inputArea = document.getElementById('inputArea');

function showToast(){}

/* ====== ハート/配布枚数 UI（DB同期） ====== */
function normDealCount(v){
  let n = Number(v);
  if(!Number.isFinite(n)) n = 1;
  n = Math.round(n);
  if(n < 1) n = 1;
  if(n > 3) n = 3;
  return n;
}
function normHearts(h){
  if(Array.isArray(h)){
    return [h[0],h[1],h[2]].map(v => (v ? 1 : 0));
  }
  if(h && typeof h === 'object'){
    const a0 = (h[0] ?? h['0'] ?? 1);
    const a1 = (h[1] ?? h['1'] ?? 1);
    const a2 = (h[2] ?? h['2'] ?? 1);
    return [a0,a1,a2].map(v => (v ? 1 : 0));
  }
  return [1,1,1];
}
function topicControls(){
  const tc = state.room?.topicControls || {};
  return {
    hearts: normHearts(tc.hearts),
    dealCount: normDealCount(tc.dealCount ?? 1),
  };
}
async function ensureTopicControls(){
  if(!state.roomCode) return;
  const tcRef = ref(db, `rooms/${state.roomCode}/topicControls`);
  await runTransaction(tcRef, (cur) => {
    if(cur == null){
      return { hearts:[1,1,1], dealCount:1 };
    }
    const hearts = normHearts(cur.hearts);
    const dealCount = normDealCount(cur.dealCount ?? 1);
    if(!cur.hearts || cur.dealCount == null){
      return { ...cur, hearts, dealCount };
    }
    return cur;
  });
}
async function toggleHeart(idx){
  if(!state.roomCode) return;
  const hRef = ref(db, `rooms/${state.roomCode}/topicControls/hearts`);
  await runTransaction(hRef, (cur) => {
    let arr = normHearts(cur);
    arr[idx] = arr[idx] ? 0 : 1;
    return arr;
  });
}
async function incDealCount(){
  if(!state.roomCode) return;
  const dRef = ref(db, `rooms/${state.roomCode}/topicControls/dealCount`);
  await runTransaction(dRef, (cur) => {
    const n = normDealCount(cur ?? 1);
    return (n % 3) + 1;
  });
}

/* ====== 手札（複数枚）ユーティリティ ====== */
function getHandCards(handData){
  if(!handData) return [];
  if(Array.isArray(handData.cards)) return handData.cards.filter(n => typeof n === 'number');
  if(typeof handData.card === 'number') return [handData.card];
  return [];
}
function getHandCount(handData){ return getHandCards(handData).length; }

/* =========================
   ✅ ヘルプ（お題 3×10）
   ========================= */

/* お題 */
const TOPIC_POOL = ["コンビニの商品の人気","100円ショップの商品の人気","飲食店の人気","駅の人気","中華料理の人気","学校給食の人気","有名人の人気","子供に人気なもの","アニメ・漫画のキャラの人気","ゲームキャラの人気（モンスター含む）","キャラクターの人気（ゆるキャラ含む）","プレゼント・お土産の人気","建物の人気","住みたい国や場所の人気","アプリ・ウェブサービスの人気","乗り物の人気","俳優の人気","悪役の人気","食べ物の人気","飲み物の人気","生き物の人気","おもちゃの人気","電化製品の人気","映画の人気","ミュージシャンの人気","お菓子・スイーツ・アイスの人気","ペットの人気","職業の人気","おにぎりの具の人気","パンの種類の人気","趣味の人気","メーカー（ブランド）の人気","アニメ・漫画の人気","ゲームの人気","和食料理の人気","洋食料理の人気","歴史上の人物の人気","声優の人気","童話の人気","歌・曲の人気","映画の登場人物の人気","アスリートの人気","スポーツの人気","テレビ番組の人気","恋人にしたい職業の人気","デートスポットの人気","ハネムーンで行きたい場所の人気","酒のつまみ・居酒屋メニューの人気","化粧品の人気","ボードゲームの人気","資格・免許の人気","旅行したい国や場所の人気","旅行先に持っていきたいもの","ゾンビと戦うときに持っていきたいもの","無人島に持っていきたいもの","一人暮らしに必要なもの","美しいもの","こわいもの","楽しいこと","嬉しいこと","カバンに入っていたら嬉しいもの","言われて嬉しい言葉","なりたい生き物","なりたい歴史上の人物","なりたい有名人","なりたいキャラ","生き物の大きさ","学校にあるものの大きさ","歴史上の人物の強さ","映画の登場人物の強さ","生き物の強さ","アニメ・漫画のキャラの強さ","ゲームキャラの強さ（モンスター含む）","強そうな言葉（漢字、熟語など）","強そうな効果音（創作OK）","有名人の年収・資産","重そうなもの","ボードゲームの（物理的な）重さ","食べ物のカロリー","モテる条件・特技","やわらかそうなもの","カッコいいもの","カッコいいセリフ","カッコいい苗字・名前","かわいいもの","小学生が好きな言葉","中高生が好きな言葉","人生で大切なもの・こと","雪山で遭難したときにもっていたいもの","地球観光に来た宇宙人にあげたいお土産","テンションが上がるもの・こと","時代遅れの言葉","オタクが喜ぶセリフ・設定","グッとくる仕草・行動","結婚したい有名人","結婚したいキャラ","親になってほしいキャラ","ほしい特殊能力・武器（必殺技・道具）","便利なもの","されたいプロポーズ（セリフ・シチュエーション）"];

function pickRandom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function shuffleCopy(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

/* ✅ ヘルプ用：30枚（3×10）をDBに保持 */
function helpTopicsList(){
  // room.helpTopics = { list:[...30], at:Date.now() } を想定
  const list = state.room?.helpTopics?.list;
  if(Array.isArray(list) && list.length === 30) return list;
  return null;
}
async function ensureHelpTopics(){
  if(!state.roomCode) return;
  const htRef = ref(db, `rooms/${state.roomCode}/helpTopics`);
  await runTransaction(htRef, (cur) => {
    if(cur && Array.isArray(cur.list) && cur.list.length === 30) return cur;
    const list = shuffleCopy(TOPIC_POOL).slice(0, 30);
    return { list, at: Date.now() };
  });
}
async function reshuffleHelpTopics(){
  if(!state.roomCode) return;
  const list = shuffleCopy(TOPIC_POOL).slice(0, 30);
  await set(ref(db, `rooms/${state.roomCode}/helpTopics`), { list, at: Date.now() });
}

/* ✅ お題変更（クリックで、そのお題に変わる） */
async function setTopicText(text){
  if(!state.roomCode) return;
  const topicText = String(text || '').trim();
  if(!topicText) return;
  await update(ref(db, `rooms/${state.roomCode}`), {
    topic: { text: topicText, at: Date.now() }
  });
}

/* ✅ ヘルプ描画 */
function renderHelpList(){
  helpBody.innerHTML = '';

  const grid = document.createElement('div');
  grid.className = 'topic-grid';

  // 無ければローカル仮表示（開いた時にensureで埋まる）
  const topics = helpTopicsList() || shuffleCopy(TOPIC_POOL).slice(0, 30);

  topics.forEach((t) => {
    const card = document.createElement('div');
    card.className = 'topic-help-card';
    // ✅ 既存のお題カード設定に合わせて：topic-card と同じ背景/文字（CSSで固定）
    card.innerHTML = `<div class="ttext">${String(t)}</div>`;
    card.addEventListener('click', async (e) => {
      e.stopPropagation();
      await setTopicText(t);
      closeHelp();
    });
    grid.appendChild(card);
  });

  helpBody.appendChild(grid);
}

async function openHelp(){
  await ensureHelpTopics();     // ✅ 初回/欠損時にDBへ30枚確定
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
}
function closeHelp(){ helpBackdrop.classList.add('hidden'); }

helpBtn.addEventListener('click', async () => {
  if (joinBox.classList.contains('hidden')) await openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => { if (e.target === helpBackdrop) closeHelp(); });

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;
let latestPlayers = [];

/* ✅ 表カードが1枚でもあるか？（1枚目公開だけ確認するため） */
function anyFaceUp(){
  return Object.values(state.fieldCards || {}).some(fc => !!fc?.faceUp);
}

/* =========================
   ✅ 入力ポップ（カードごと）
   ========================= */
let editingKey = null;
let inputMode = null;
function noteKeyForHand(ownerId, value){
  return `H:${ownerId}:${value}`;
}
function noteKeyForField(fieldCardId){
  return `F:${fieldCardId}`;
}
function openNotePopFor(key, label){
  inputMode = 'note';
  editingKey = key;
  inputTitle.textContent = `カード入力：${label}`;
  inputArea.value = String(state.notes?.[key] ?? '');
  inputBackdrop.classList.remove('hidden');
  setTimeout(()=>inputArea.focus(), 0);
}
function openTopicEditPop(currentText){
  inputMode = 'topic';
  editingKey = null;
  inputTitle.textContent = 'お題を編集';
  inputArea.value = String(currentText ?? '').trim();
  inputBackdrop.classList.remove('hidden');
  setTimeout(()=>inputArea.focus(), 0);
}
async function commitNoteAndClose(){
  if(!state.roomCode) {
    inputBackdrop.classList.add('hidden');
    editingKey = null;
    inputMode = null;
    return;
  }
  const text = String(inputArea.value ?? '').trim();
  if(inputMode === 'note'){
    if(editingKey){
      await set(ref(db, `rooms/${state.roomCode}/notes/${editingKey}`), text);
    }
  }else if(inputMode === 'topic'){
    await setTopicText(text);
  }
  inputBackdrop.classList.add('hidden');
  editingKey = null;
  inputMode = null;
}
inputBackdrop.addEventListener('click', async (e) => {
  if(e.target === inputBackdrop){
    await commitNoteAndClose();
  }
});
inputPop.addEventListener('click', (e)=>e.stopPropagation());

function attachCardNoteByKey(el, noteKey){
  const txt = String(state.notes?.[noteKey] ?? '').trim();
  const old = el.querySelector('.card-note');
  if(!txt){
    if(old) old.remove();
    return;
  }
  const note = old || document.createElement('div');
  note.className = 'card-note';
  note.textContent = txt;
  if(!old) el.appendChild(note);
}

/* カード数字の見た目 */
function hslToHex(h, s, l){
  s/=100; l/=100;
  const k = n => (n + h/30) % 12;
  const a = s * Math.min(l, 1-l);
  const f = n => l - a * Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n), 1)));
  const r = Math.round(255*f(0));
  const g = Math.round(255*f(8));
  const b = Math.round(255*f(4));
  return '#' + [r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('');
}
function fnv1a32(str){
  let h = 0x811c9dc5;
  for (let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 0x01000193);
  }
  return h >>> 0;
}
function mulberry32(seed){
  let a = seed >>> 0;
  return function(){
    a |= 0; a = (a + 0x6D2B79F5) | 0;
    let t = Math.imul(a ^ (a >>> 15), 1 | a);
    t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function ensureCardStyles(){
  if(state.cardStyle && Object.keys(state.cardStyle).length === 100) return;
  const seed = (state.roomSeed ?? 123456789) >>> 0;

  const hues = Array.from({length:100}, (_,i)=>i*(360/100));
  const rnd = mulberry32(seed ^ 0xC0FFEE11);
  for(let i=hues.length-1;i>0;i--){
    const j = Math.floor(rnd()*(i+1));
    [hues[i], hues[j]] = [hues[j], hues[i]];
  }

  const map = {};
  for(let v=1; v<=100; v++){
    const r2 = mulberry32(fnv1a32(`${seed}:rot:${v}`) ^ 0x9E3779B9);
    const rot = (r2()*20 - 10);
    const hue = hues[v-1];
    const ink = hslToHex(hue, 92, 52);
    map[v] = { ink, rot };
  }
  state.cardStyle = map;
}
function applyNumberStyle(el, value){
  ensureCardStyles();
  const st = state.cardStyle?.[value];
  if(!st) return;
  el.style.setProperty('--ink', st.ink);
  el.style.setProperty('--rot', `${st.rot.toFixed(2)}deg`);
}

/* クリスタル */
function clamp01(v){ return Math.max(0, Math.min(1, v)); }
function hexToRgb(hex){
  const s = hex.replace('#','').trim();
  const v = s.length===3 ? s.split('').map(c=>c+c).join('') : s;
  const n = parseInt(v, 16);
  return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
}
function mix(c1, c2, t){
  const a = hexToRgb(c1), b = hexToRgb(c2);
  const r = Math.round(a.r + (b.r-a.r)*t);
  const g = Math.round(a.g + (b.g-a.g)*t);
  const b2 = Math.round(a.b + (b.b-a.b)*t);
  return '#' + [r,g,b2].map(x=>x.toString(16).padStart(2,'0')).join('');
}

/* =========================
   ✅ 数字カード背景：1→100 を指定アンカーで補間
   ========================= */
const NUM_BG_ANCHORS = [
  { v:100, hex:"#F2C94C" },
  { v: 90, hex:"#E6B93E" },
  { v: 80, hex:"#D9A63A" },
  { v: 70, hex:"#C89634" },
  { v: 60, hex:"#B8873A" },
  { v: 50, hex:"#A6773F" },
  { v: 40, hex:"#916C3C" },
  { v: 30, hex:"#7C5D39" },
  { v: 20, hex:"#665034" },
  { v: 10, hex:"#4C3925" },
  { v:  5, hex:"#3A2B1E" },
  { v:  1, hex:"#241A12" },
].sort((a,b)=>a.v-b.v);

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function rgbToHex(r,g,b){
  return '#' + [r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('');
}
function mixHex(a, b, t){
  const A = hexToRgb(a), B = hexToRgb(b);
  const r = Math.round(A.r + (B.r - A.r) * t);
  const g = Math.round(A.g + (B.g - A.g) * t);
  const bb = Math.round(A.b + (B.b - A.b) * t);
  return rgbToHex(r,g,bb);
}
function colorForValueByAnchors(value){
  const v = clamp(Number(value)||1, 1, 100);
  for(const p of NUM_BG_ANCHORS){
    if(p.v === v) return p.hex;
  }
  let p0 = NUM_BG_ANCHORS[0];
  let p1 = NUM_BG_ANCHORS[NUM_BG_ANCHORS.length-1];
  for(let i=0;i<NUM_BG_ANCHORS.length-1;i++){
    const a = NUM_BG_ANCHORS[i];
    const b = NUM_BG_ANCHORS[i+1];
    if(v >= a.v && v <= b.v){
      p0 = a; p1 = b;
      break;
    }
  }
  const span = (p1.v - p0.v) || 1;
  const t = (v - p0.v) / span;
  return mixHex(p0.hex, p1.hex, t);
}
function applyCardBg(el, value){
  const base = colorForValueByAnchors(value);
  el.style.setProperty('--bgSolid', base);
  const rgb = hexToRgb(base);
  const lumin = (0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b) / 255;
  el.style.setProperty('--numShadow', lumin < 0.28 ? 'rgba(255,255,255,.35)' : 'rgba(0,0,0,.18)');
}

function hslToRgb(h, s, l){
  s/=100; l/=100;
  const k = n => (n + h/30) % 12;
  const a = s * Math.min(l, 1-l);
  const f = n => l - a * Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n), 1)));
  return { r:Math.round(255*f(0)), g:Math.round(255*f(8)), b:Math.round(255*f(4)) };
}
function paletteFromSeed(seed, n=20){
  const rnd = mulberry32(seed ^ 0xA53C9E37);
  const offset = rnd()*360;
  const sat = 92, light = 45;
  const arr = [];
  for(let i=0;i<n;i++){
    const h = (offset + (360/n)*i) % 360;
    const rgb = hslToRgb(h, sat, light);
    arr.push('#' + [rgb.r,rgb.g,rgb.b].map(x=>x.toString(16).padStart(2,'0')).join(''));
  }
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(rnd()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
  return arr;
}

let svgUid = 0;
function crystalSVG(spec, size=18){
  if(!spec || !spec.color || !spec.seed){
    return `<svg viewBox="0 0 64 64" aria-hidden="true"><circle cx="32" cy="32" r="10" fill="#ddd"/></svg>`;
  }
  const uid = (++svgUid);
  const idBase  = `base_${spec.seed}_${uid}`;
  const idShade = `shade_${spec.seed}_${uid}`;
  const idHi    = `hi_${spec.seed}_${uid}`;

  const base = spec.color;
  const c1 = mix(base, "#ffffff", 0.72);
  const c2 = mix(base, "#ffffff", 0.10);
  const c3 = mix(base, "#000000", 0.62);

  const rnd = mulberry32(spec.seed);
  const cx = 32, cy = 32;
  const ptsN = 8;
  const pts = [];
  for(let i=0;i<ptsN;i++){
    const ang = (-90 + (360/ptsN)*i) * Math.PI/180;
    const rad = 24 + rnd()*8;
    const jx = (rnd()-0.5)*4, jy = (rnd()-0.5)*4;
    const x = cx + Math.cos(ang)*rad + jx;
    const y = cy + Math.sin(ang)*rad + jy;
    pts.push([x,y]);
  }
  const d = `M ${pts.map(p=>`${p[0].toFixed(1)} ${p[1].toFixed(1)}`).join(' L ')} Z`;

  const i1 = 1 + Math.floor(rnd()*2);
  const i2 = i1 + 2;
  const i3 = i2 + 2;
  const p1 = pts[i1%ptsN], p2 = pts[i2%ptsN], p3 = pts[i3%ptsN];
  const mid = [(p2[0]+cx)/2, (p2[1]+cy)/2];
  const shadeD = `M ${p1[0].toFixed(1)} ${p1[1].toFixed(1)} L ${p2[0].toFixed(1)} ${p2[1].toFixed(1)} L ${p3[0].toFixed(1)} ${p3[1].toFixed(1)} L ${mid[0].toFixed(1)} ${mid[1].toFixed(1)} Z`;

  const hx = 18 + rnd()*6;
  const hy = 14 + rnd()*6;
  const hiD = `
    M ${hx.toFixed(1)} ${hy.toFixed(1)}
    C ${(hx-6).toFixed(1)} ${(hy+10).toFixed(1)} ${(hx-2).toFixed(1)} ${(hy+20).toFixed(1)} ${(hx+2).toFixed(1)} ${(hy+26).toFixed(1)}
    C ${(hx+6).toFixed(1)} ${(hy+34).toFixed(1)} ${(hx+3).toFixed(1)} ${(hy+40).toFixed(1)} ${(hx-2).toFixed(1)} ${(hy+44).toFixed(1)}
    C ${(hx-4).toFixed(1)} ${(hy+48).toFixed(1)} ${(hx+2).toFixed(1)} ${(hy+50).toFixed(1)} ${(hx+8).toFixed(1)} ${(hy+48).toFixed(1)}
    C ${(hx+16).toFixed(1)} ${(hy+44).toFixed(1)} ${(hx+14).toFixed(1)} ${(hy+34).toFixed(1)} ${(hx+12).toFixed(1)} ${(hy+26).toFixed(1)}
    C ${(hx+10).toFixed(1)} ${(hy+18).toFixed(1)} ${(hx+14).toFixed(1)} ${(hy+12).toFixed(1)} ${(hx+12).toFixed(1)} ${(hy+8).toFixed(1)}
    C ${(hx+10).toFixed(1)} ${(hy+4).toFixed(1)} ${(hx+4).toFixed(1)} ${(hy+4).toFixed(1)} ${hx.toFixed(1)} ${hy.toFixed(1)} Z
  `;

  return `
  <svg viewBox="0 0 64 64" role="img" aria-hidden="true">
    <defs>
      <linearGradient id="${idBase}" x1="14" y1="8" x2="50" y2="58" gradientUnits="userSpaceOnUse">
        <stop offset="0"   stop-color="${c1}" stop-opacity=".95"/>
        <stop offset=".6"  stop-color="${c2}" stop-opacity=".42"/>
        <stop offset="1"   stop-color="${c3}" stop-opacity=".16"/>
      </linearGradient>
      <linearGradient id="${idShade}" x1="42" y1="18" x2="28" y2="58" gradientUnits="userSpaceOnUse">
        <stop offset="0" stop-color="${c3}" stop-opacity=".20"/>
        <stop offset="1" stop-color="${c3}" stop-opacity="0"/>
      </linearGradient>
      <linearGradient id="${idHi}" x1="22" y1="14" x2="32" y2="46" gradientUnits="userSpaceOnUse">
        <stop offset="0" stop-color="#ffffff" stop-opacity=".78"/>
        <stop offset="1" stop-color="#ffffff" stop-opacity="0"/>
      </linearGradient>
    </defs>

    <path d="${d}"
      fill="url(#${idBase})"
      stroke="${mix(base, "#ffffff", 0.55)}" stroke-opacity=".55" stroke-width="1.6"
      stroke-linejoin="round"/>
    <path d="${shadeD}" fill="url(#${idShade})"/>
    <path d="${hiD}" fill="url(#${idHi})" opacity=".92"/>
  </svg>`;
}

function cryptoUint32(){
  const u = new Uint32Array(1);
  crypto.getRandomValues(u);
  return u[0] >>> 0;
}

async function ensureRoomSeed(){
  if(!state.roomCode) return null;
  const seedRef = ref(db, `rooms/${state.roomCode}/seed`);
  const res = await runTransaction(seedRef, (cur) => {
    if (cur === null || cur === undefined) return cryptoUint32() || 123456789;
    return cur;
  });
  state.roomSeed = (res && res.snapshot) ? (res.snapshot.val() >>> 0) : state.roomSeed;
  ensureCardStyles();
  return state.roomSeed;
}

async function ensureCrystalForPlayer(playerId){
  if(!state.roomCode) return;
  const seed = state.roomSeed ?? await ensureRoomSeed();
  if(seed == null) return;

  const palette = paletteFromSeed(seed, 20);
  const crystalsRef = ref(db, `rooms/${state.roomCode}/crystals`);

  await runTransaction(crystalsRef, (cur) => {
    cur = cur || {};
    if (cur[playerId]) return cur;

    const used = new Set(
      Object.values(cur)
        .filter(v => v && typeof v === 'object' && v.color)
        .map(v => v.color)
    );
    const color = palette.find(c => !used.has(c)) || palette[0];
    cur[playerId] = { color, seed: fnv1a32(`${seed}:${playerId}`) };
    return cur;
  });
}

async function transferSeatAssets(fromPlayerId, toPlayerId){
  if(!state.roomCode) return;
  if(!fromPlayerId || !toPlayerId || fromPlayerId === toPlayerId) return;

  const base = `rooms/${state.roomCode}`;
  const [handsSnap, notesSnap, crystalsSnap, fieldSnap] = await Promise.all([
    get(ref(db, `${base}/hands`)),
    get(ref(db, `${base}/notes`)),
    get(ref(db, `${base}/crystals`)),
    get(ref(db, `${base}/fieldCards`))
  ]);

  const hands = handsSnap.val() || {};
  const notes = notesSnap.val() || {};
  const crystals = crystalsSnap.val() || {};
  const fieldCards = fieldSnap.val() || {};

  const updates = {};
  if(hands[fromPlayerId]){
    updates[`${base}/hands/${toPlayerId}`] = hands[fromPlayerId];
    updates[`${base}/hands/${fromPlayerId}`] = null;
  }

  const handPrefix = `H:${fromPlayerId}:`;
  for(const [key, value] of Object.entries(notes)){
    if(!key.startsWith(handPrefix)) continue;
    const newKey = `H:${toPlayerId}:${key.slice(handPrefix.length)}`;
    updates[`${base}/notes/${newKey}`] = value;
    updates[`${base}/notes/${key}`] = null;
  }

  if(crystals[fromPlayerId]){
    updates[`${base}/crystals/${toPlayerId}`] = crystals[fromPlayerId];
    updates[`${base}/crystals/${fromPlayerId}`] = null;
  }

  for(const [cardId, card] of Object.entries(fieldCards)){
    if(card && card.ownerId === fromPlayerId){
      updates[`${base}/fieldCards/${cardId}/ownerId`] = toPlayerId;
    }
  }

  if(Object.keys(updates).length){
    await update(ref(db), updates);
  }
}

/* 提出人数チェック（配布枚数ぶん提出が必要） */
function expectedPlayerIds(){
  return (latestPlayers || []).map(p=>p.id).filter(Boolean);
}
function dealCountAtStart(){
  const v = state.room?.dealCountAtStart;
  if(v != null) return normDealCount(v);
  return topicControls().dealCount;
}
function allSubmitted(){
  const ids = expectedPlayerIds();
  if(!ids.length) return false;

  const need = dealCountAtStart();
  const entries = Object.values(state.fieldCards || {}).filter(Boolean);

  return ids.every(pid => {
    const n = entries.filter(fc => fc.ownerId === pid).length;
    return n >= need;
  });
}

/* ✅ ハートSVG */
function heartSVG(filled){
  const fill = filled ? '#d946ef' : '#9ca3af';
  return `
  <svg viewBox="0 0 24 24" aria-hidden="true">
    <path
      d="M12 21.1C12 21.1 3.6 16 2.4 10.2C1.6 6.5 4 3.6 7.4 3.6C9.5 3.6 11.1 4.8 12 6.2C12.9 4.8 14.5 3.6 16.6 3.6C20 3.6 22.4 6.5 21.6 10.2C20.4 16 12 21.1 12 21.1Z"
      fill="${fill}"
      stroke="#111"
      stroke-width="1.8"
      stroke-linejoin="round"
      stroke-linecap="round"
    />
  </svg>`;
}

/* =========================
   ✅ お題：1行に収まるまで自動で文字サイズを下げる
   ========================= */
let topicFitRAF = 0;

function topicControlsKey(tc){
  return JSON.stringify({
    hearts: tc?.hearts || [],
    dealCount: tc?.dealCount
  });
}

function fitTopicText(){
  cancelAnimationFrame(topicFitRAF);
  topicFitRAF = requestAnimationFrame(() => {
    const el = plazaEl.querySelector('.topic-card');
    if(!el) return;

    const MAX = 20;
    const MIN = 10;
    const STEP = 0.5;

    el.style.whiteSpace = 'nowrap';
    el.style.overflow = 'hidden';
    el.style.fontSize = `${MAX}px`;

    let size = MAX;
    while(size > MIN && el.scrollWidth > el.clientWidth){
      size -= STEP;
      el.style.fontSize = `${size}px`;
    }
  });
}
window.addEventListener('resize', fitTopicText);

function renderTopic(){
  const old = plazaEl.querySelector('.topic-bar');
  if(old) old.remove();
  if(!state.topic || !state.topic.text) return;

  const tc = topicControls();
  const bar = document.createElement('div');
  bar.className = 'topic-bar';
  bar.dataset.topicText = String(state.topic.text);
  bar.dataset.topicControls = topicControlsKey(tc);

  const t = document.createElement('div');
  t.className = 'topic-card';
  t.textContent = String(state.topic.text);
  t.setAttribute('role', 'button');
  t.setAttribute('aria-label', 'お題を編集');
  t.tabIndex = 0;
  t.addEventListener('click', async (e) => {
    e.stopPropagation();
    openTopicEditPop(state.topic?.text);
  });
  t.addEventListener('keydown', async (e) => {
    if(e.key !== 'Enter' && e.key !== ' ') return;
    e.preventDefault();
    e.stopPropagation();
    openTopicEditPop(state.topic?.text);
  });

  const ui = document.createElement('div');
  ui.className = 'topic-ui';

  const heartRow = document.createElement('div');
  heartRow.className = 'heart-row';
  for(let i=0;i<3;i++){
    const b = document.createElement('button');
    b.className = 'heart-btn';
    b.type = 'button';
    b.setAttribute('aria-label', `heart ${i+1}`);
    b.innerHTML = heartSVG(!!tc.hearts[i]);
    b.addEventListener('click', async (e) => {
      e.stopPropagation();
      await toggleHeart(i);
    });
    heartRow.appendChild(b);
  }

  const stack = document.createElement('div');
  stack.className = 'deal-stack';
  const n = tc.dealCount;
  for(let i=0;i<n;i++){
    const c = document.createElement('div');
    c.className = 'deal-card';
    c.style.left = `${i*10}px`;
    c.style.zIndex = String(10+i);
    stack.appendChild(c);
  }

  const plus = document.createElement('button');
  plus.className = 'deal-plus';
  plus.type = 'button';
  plus.textContent = '+1';
  plus.addEventListener('click', async (e) => {
    e.stopPropagation();
    await incDealCount();
  });

  ui.appendChild(heartRow);
  ui.appendChild(stack);
  ui.appendChild(plus);

  bar.appendChild(t);
  bar.appendChild(ui);

  plazaEl.appendChild(bar);
  fitTopicText();
}

/* ===== 広場カード ===== */
let localDraggingFieldId = null;
let fieldDragOffset = {dx:0, dy:0};
let rafPending = false;
let pendingFieldXY = null;
let fieldPointer = null;

const CLICK_DELAY_MS = 220;
const clickTimers = new Map();
const DOUBLE_TAP_MS = 300;
const lastTapTimes = new Map();
const suppressClickUntil = new Map();

function cancelPendingClick(cardId){
  const t = clickTimers.get(cardId);
  if(t){
    clearTimeout(t);
    clickTimers.delete(cardId);
  }
}
function scheduleSingleClick(cardId, fn){
  cancelPendingClick(cardId);
  const tid = setTimeout(() => {
    clickTimers.delete(cardId);
    fn();
  }, CLICK_DELAY_MS);
  clickTimers.set(cardId, tid);
}

function plazaRect(){ return plazaEl.getBoundingClientRect(); }
function setFieldCardElPos(el, x, y){
  el.style.left = `${(x*100).toFixed(3)}%`;
  el.style.top  = `${(y*100).toFixed(3)}%`;
}

/* ✅ 1枚目公開確認ダイアログ */
let pendingRevealId = null;
function closeRevealDialog(){
  revealDialog.classList.add('hidden');
  pendingRevealId = null;
}
function openRevealDialog(cardId, label){
  pendingRevealId = cardId;
  revealMessage.textContent = `「${label}」を表にしますか？`;
  revealDialog.classList.remove('hidden');
}
revealDialog.addEventListener('click', (e) => {
  if(e.target === revealDialog) closeRevealDialog();
});
btnRevealNo.addEventListener('click', (e) => {
  e.stopPropagation();
  closeRevealDialog();
});
btnRevealYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if(!pendingRevealId || !state.roomCode) return closeRevealDialog();
  const id = pendingRevealId;
  closeRevealDialog();
  await revealCard(id);
});

function renderFieldCards(){
  const existingTopic = plazaEl.querySelector('.topic-bar');
  const nextTopicText = state.topic?.text ? String(state.topic.text) : null;
  const nextTopicControls = topicControlsKey(topicControls());

  if(!nextTopicText){
    if(existingTopic) existingTopic.remove();
  }else if(!existingTopic
    || existingTopic.dataset.topicText !== nextTopicText
    || existingTopic.dataset.topicControls !== nextTopicControls){
    renderTopic();
  }

  plazaEl.querySelectorAll('.field-card').forEach((el) => el.remove());

  const entries = Object.values(state.fieldCards || {}).filter(Boolean);
  entries.sort((a,b)=>(a?.z||0)-(b?.z||0));

  for(const fc of entries){
    const el = document.createElement('div');
    el.className = 'field-card';
    el.dataset.id = fc.id;

    const faceUp = !!fc.faceUp;
    if(faceUp){
      el.classList.add('faceup');
      const v = Number(fc.value);

      applyCardBg(el, v);

      const s = document.createElement('span');
      s.className = 'card-num';
      s.textContent = String(fc.value ?? '');
      applyNumberStyle(s, v);
      el.appendChild(s);
    }else{
      el.textContent = '';
      el.classList.add('back');
    }

    const x = clamp01(Number(fc.x ?? 0.5));
    const y = clamp01(Number(fc.y ?? 0.5));
    setFieldCardElPos(el, x, y);

    el.style.zIndex = String((fc.z ?? 1));

    const spec = state.crystals?.[fc.ownerId];
    const c = document.createElement('div');
    c.className = 'card-crystal';
    c.innerHTML = crystalSVG(spec, 18);
    el.appendChild(c);

    attachCardNoteByKey(el, noteKeyForField(fc.id));

    el.addEventListener('pointerdown', (e) => {
      if(!state.roomCode) return;

      localDraggingFieldId = fc.id;
      fieldPointer = { id: fc.id, downX: e.clientX, downY: e.clientY, moved:false };

      const r = plazaRect();
      const px = r.left + x * r.width;
      const py = r.top  + y * r.height;
      fieldDragOffset.dx = e.clientX - px;
      fieldDragOffset.dy = e.clientY - py;

      el.setPointerCapture(e.pointerId);
    });

    el.addEventListener('pointermove', (e) => {
      if(localDraggingFieldId !== fc.id) return;

      if(fieldPointer && !fieldPointer.moved){
        const dx = Math.abs(e.clientX - fieldPointer.downX);
        const dy = Math.abs(e.clientY - fieldPointer.downY);
        if(dx < 4 && dy < 4) return;
        fieldPointer.moved = true;

        cancelPendingClick(fc.id);

        if(state.roomCode){
          update(ref(db, `rooms/${state.roomCode}/fieldCards/${fc.id}`), { z: Date.now() });
        }
      }

      if(!fieldPointer || !fieldPointer.moved) return;

      const r = plazaRect();
      const nx = clamp01((e.clientX - r.left - fieldDragOffset.dx) / r.width);
      const ny = clamp01((e.clientY - r.top  - fieldDragOffset.dy) / r.height);

      setFieldCardElPos(el, nx, ny);

      pendingFieldXY = { id: fc.id, x: nx, y: ny };
      if(!rafPending){
        rafPending = true;
        requestAnimationFrame(() => {
          rafPending = false;
          if(!pendingFieldXY || !state.roomCode) return;
          const p = pendingFieldXY;
          pendingFieldXY = null;
          update(ref(db, `rooms/${state.roomCode}/fieldCards/${p.id}`), { x: p.x, y: p.y });
        });
      }
    });

    el.addEventListener('pointerup', (e) => {
      if(localDraggingFieldId !== fc.id) return;
      localDraggingFieldId = null;
      try{ el.releasePointerCapture(e.pointerId); }catch{}
    });

    el.addEventListener('pointercancel', () => {
      if(localDraggingFieldId === fc.id) localDraggingFieldId = null;
      fieldPointer = null;
      cancelPendingClick(fc.id);
    });

    el.addEventListener('click', () => {
      if(!state.roomCode) return;
      if(fc.ownerId !== state.userId) return;
      if(fieldPointer?.id === fc.id && fieldPointer?.moved) return;
      if((suppressClickUntil.get(fc.id) || 0) > Date.now()) return;

      scheduleSingleClick(fc.id, () => {
        openNotePopFor(noteKeyForField(fc.id), `場 ${fc.value}`);
      });
    });

    const handleRevealRequest = async () => {
      if(!state.roomCode) return;

      cancelPendingClick(fc.id);

      if(!allSubmitted()) return;
      if(fc.faceUp) return;
      if(fieldPointer?.id === fc.id && fieldPointer?.moved) return;

      if(!anyFaceUp()){
        openRevealDialog(fc.id, `カード ${fc.value}`);
        return;
      }
      await revealCard(fc.id);
    };

    el.addEventListener('dblclick', async () => {
      await handleRevealRequest();
    });

    el.addEventListener('pointerup', async (e) => {
      if(e.pointerType !== 'touch') return;
      if(fieldPointer?.id === fc.id && fieldPointer?.moved) return;
      const now = Date.now();
      const lastTap = lastTapTimes.get(fc.id) || 0;
      if(now - lastTap < DOUBLE_TAP_MS){
        lastTapTimes.delete(fc.id);
        suppressClickUntil.set(fc.id, now + DOUBLE_TAP_MS);
        await handleRevealRequest();
        return;
      }
      lastTapTimes.set(fc.id, now);
    });

    plazaEl.appendChild(el);

    el.addEventListener('pointerup', () => {
      if(fieldPointer?.id === fc.id){
        setTimeout(() => {
          if(fieldPointer?.id === fc.id) fieldPointer = null;
        }, 0);
      }
    });
  }
}

async function revealCard(cardId){
  const cardRef = ref(db, `rooms/${state.roomCode}/fieldCards/${cardId}`);
  await update(ref(db, `rooms/${state.roomCode}`), { revealStarted: true });
  await update(cardRef, { faceUp: true });
}

/* =========================================================
   ✅ 手札→広場ドラッグ（複数対応）
   ========================================================= */
let handDrag = null;
const HAND_DRAG_THRESHOLD = 6;

function createHandGhost(value){
  const g = document.createElement('div');
  g.className = 'hand-drag-ghost';

  applyCardBg(g, Number(value));

  const s = document.createElement('span');
  s.className = 'card-num';
  s.textContent = String(value);
  applyNumberStyle(s, Number(value));
  g.appendChild(s);

  document.body.appendChild(g);
  return g;
}

function cleanupHandDrag(reason=''){
  if(!handDrag) return;

  const el = handDrag.el;
  if(el){
    el.style.opacity = '';
    try{
      if(handDrag.pointerId != null) el.releasePointerCapture(handDrag.pointerId);
    }catch{}
  }

  const g = handDrag.ghost;
  if(g){
    try{ g.remove(); }catch{}
  }

  handDrag = null;
}

function moveHandGhost(e){
  if(!handDrag || !handDrag.ghost) return;
  const cx = e.clientX - handDrag.offX;
  const cy = e.clientY - handDrag.offY;
  handDrag.ghost.style.left = `${cx}px`;
  handDrag.ghost.style.top  = `${cy}px`;
}

function beginHandPointer(cardEl, value, e){
  if(!state.roomCode) return;

  cleanupHandDrag('start-over');

  handDrag = {
    el: cardEl,
    value,
    pointerId: e.pointerId,
    startX: e.clientX,
    startY: e.clientY,
    offX: 0,
    offY: 0,
    ghost: null,
    dragging: false
  };

  cardEl.setPointerCapture(e.pointerId);
}

function ensureActualHandDrag(e){
  if(!handDrag || handDrag.dragging) return;
  const dx = Math.abs(e.clientX - handDrag.startX);
  const dy = Math.abs(e.clientY - handDrag.startY);
  if(dx < HAND_DRAG_THRESHOLD && dy < HAND_DRAG_THRESHOLD) return;

  const cardEl = handDrag.el;
  const r = cardEl.getBoundingClientRect();

  handDrag.offX = e.clientX - (r.left + r.width/2);
  handDrag.offY = e.clientY - (r.top  + r.height/2);

  handDrag.ghost = createHandGhost(handDrag.value);
  handDrag.dragging = true;

  cardEl.style.opacity = '0';

  moveHandGhost(e);
}

function moveHandPointer(e){
  if(!handDrag) return;
  ensureActualHandDrag(e);
  if(handDrag.dragging) moveHandGhost(e);
}

async function endHandPointer(e){
  if(!handDrag) return { type:'none' };

  const hd = handDrag;

  if(!hd.dragging){
    cleanupHandDrag('click');
    return { type:'click', value: hd.value };
  }

  const value = hd.value;
  const dropX = e.clientX - hd.offX;
  const dropY = e.clientY - hd.offY;

  cleanupHandDrag('drop');

  const r = plazaRect();
  const inside = (dropX >= r.left && dropX <= r.right && dropY >= r.top && dropY <= r.bottom);

  if(!inside || !state.roomCode){
    return { type:'cancel', value };
  }

  const x = clamp01((dropX - r.left) / r.width);
  const y = clamp01((dropY - r.top ) / r.height);

  const listRef = ref(db, `rooms/${state.roomCode}/fieldCards`);
  const newRef = push(listRef);
  const id = newRef.key;

  const handNoteKey = noteKeyForHand(state.userId, value);
  const copiedText = String(state.notes?.[handNoteKey] ?? '').trim();

  const hRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const snap = await get(hRef);
  const curHand = snap.val();
  const arr = getHandCards(curHand).slice();
  const idx = arr.indexOf(value);
  if(idx >= 0) arr.splice(idx, 1);

  const base = `rooms/${state.roomCode}`;
  const updates = {};
  updates[`${base}/fieldCards/${id}`] = {
    id,
    ownerId: state.userId,
    value,
    x, y,
    z: Date.now(),
    faceUp: false
  };
  if(copiedText){
    updates[`${base}/notes/${noteKeyForField(id)}`] = copiedText;
  }
  updates[`${base}/hands/${state.userId}`] = (arr.length ? { cards: arr } : null);

  await update(ref(db), updates);

  return { type:'drop', value, fieldId:id };
}

window.addEventListener('blur', () => cleanupHandDrag('blur'));
document.addEventListener('visibilitychange', () => {
  if(document.visibilityState !== 'visible') cleanupHandDrag('hidden');
});

/* ===== 既存ロジック ===== */
function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');
}

function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    state.revealStarted = !!state.room.revealStarted;

    state.topic = state.room.topic || null;

    // ✅ ヘルプ30枚が入ってきたら、開いている時に再描画
    if(!helpBackdrop.classList.contains('hidden')){
      renderHelpList();
    }

    syncSeatUI();
    renderFieldCards();
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
  });
}
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
  });
}
function subscribeCrystals(){
  const cRef = ref(db, `rooms/${state.roomCode}/crystals`);
  onValue(cRef, snap => {
    state.crystals = snap.val() || {};
    renderHands();
  });
}
function subscribeFieldCards(){
  const fRef = ref(db, `rooms/${state.roomCode}/fieldCards`);
  onValue(fRef, snap => {
    state.fieldCards = snap.val() || {};
    renderFieldCards();
    renderHands();
  });
}
function subscribeNotes(){
  const nRef = ref(db, `rooms/${state.roomCode}/notes`);
  onValue(nRef, snap => {
    state.notes = snap.val() || {};
    renderHands();
    renderFieldCards();
  });
}

/* ===== 手札描画（複数枚） ===== */
function renderMyHand(){
  myHandEl.innerHTML = '';
  const myId = state.userId;
  const handData = state.hands[myId];
  const cards = getHandCards(handData);
  if (!cards.length) return;

  for(const v of cards){
    const cardEl = document.createElement('div');
    cardEl.className = 'my-card';

    applyCardBg(cardEl, Number(v));

    const s = document.createElement('span');
    s.className = 'card-num';
    s.textContent = String(v);
    applyNumberStyle(s, Number(v));
    cardEl.appendChild(s);

    const k = noteKeyForHand(myId, v);
    attachCardNoteByKey(cardEl, k);

    const hint = document.createElement('div');
    hint.className = 'hint';
    hint.textContent = '←広場にドラッグ';
    cardEl.appendChild(hint);

    cardEl.addEventListener('pointerdown', (e) => {
      beginHandPointer(cardEl, v, e);
    });
    cardEl.addEventListener('pointermove', (e) => {
      moveHandPointer(e);
    });
    cardEl.addEventListener('pointerup', async (e) => {
      const res = await endHandPointer(e);
      if(res.type === 'click'){
        openNotePopFor(k, `手札 ${v}`);
      }
    });
    cardEl.addEventListener('pointercancel', () => {
      cleanupHandDrag('pointercancel');
    });

    myHandEl.appendChild(cardEl);
  }
}
function renderHands(){
  renderMyHand();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  renderFieldCards();
}

/* URL room */
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  await ensureRoomSeed();
  await ensureTopicControls();
  await ensureHelpTopics(); // ✅ 入室時にもヘルプ30枚を確定（無ければ作る）
  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribeCrystals();
  subscribeFieldCards();
  subscribeNotes();

  if(state.seatedTable !== null){
    await ensureCrystalForPlayer(state.userId);
  }
  syncSeatUI();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';

      for(let i=2; i<=20; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });

          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');

          await ensureCrystalForPlayer(state.userId);
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 20;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');

        await ensureCrystalForPlayer(state.userId);
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await ensureRoomSeed();
    ensureCardStyles();

    for(const p of players){
      ensureCrystalForPlayer(p.id);
    }

    await ensureTopicControls();

    await syncSeatUI();
    renderPlayerCircle(players);
  });
}

/* 配置ロジック */
function pointOnRoundedRectPerimeter(t, w, h, r){
  r = Math.max(0, Math.min(r, Math.min(w,h)/2));

  const straightW = Math.max(0, w - 2*r);
  const straightH = Math.max(0, h - 2*r);
  const L = 2*(straightW + straightH) + 2*Math.PI*r;

  let d = (t - Math.floor(t)) * L;

  if(d <= straightW){
    return { x: r + d, y: 0 };
  }
  d -= straightW;

  const arcLen = (Math.PI/2)*r;
  if(d <= arcLen){
    const a = (-Math.PI/2) + (d/arcLen)*(Math.PI/2);
    return { x: w - r + Math.cos(a)*r, y: r + Math.sin(a)*r };
  }
  d -= arcLen;

  if(d <= straightH){
    return { x: w, y: r + d };
  }
  d -= straightH;

  if(d <= arcLen){
    const a = (0) + (d/arcLen)*(Math.PI/2);
    return { x: w - r + Math.cos(a)*r, y: h - r + Math.sin(a)*r };
  }
  d -= arcLen;

  if(d <= straightW){
    return { x: (w - r) - d, y: h };
  }
  d -= straightW;

  if(d <= arcLen){
    const a = (Math.PI/2) + (d/arcLen)*(Math.PI/2);
    return { x: r + Math.cos(a)*r, y: h - r + Math.sin(a)*r };
  }
  d -= arcLen;

  if(d <= straightH){
    return { x: 0, y: (h - r) - d };
  }
  d -= straightH;

  const a = (Math.PI) + (Math.min(d, arcLen)/arcLen)*(Math.PI/2);
  return { x: r + Math.cos(a)*r, y: r + Math.sin(a)*r };
}

function getBottomCenterAnchorT(w, h, r){
  r = Math.max(0, Math.min(r, Math.min(w,h)/2));
  const straightW = Math.max(0, w - 2*r);
  const straightH = Math.max(0, h - 2*r);
  const arcLen = (Math.PI/2) * r;
  const L = 2*(straightW + straightH) + 2*Math.PI*r;
  if (!L || !straightW) return 0;

  const startBottom = straightW + arcLen + straightH + arcLen;
  const bottomCenterOffset = straightW / 2;
  return (startBottom + bottomCenterOffset) / L;
}

function renderPlayerCircle(players){
  playerCircle.innerHTML = '';
  if (!players.length) return;

  const rectW = 86;
  const rectH = 100;
  const rectX0 = (100 - rectW)/2;
  const rectY0 = (100 - rectH)/2;

  const cornerR = 10;

  const meIndex = players.findIndex(p => p.id === state.userId);
  const N = players.length;
  const step = 1 / N;

  const anchor = getBottomCenterAnchorT(rectW, rectH, cornerR);
  const offset = (meIndex >= 0) ? (anchor - meIndex * step) : anchor;

  function placePlayer(p, t, isMe=false){
    const pt = pointOnRoundedRectPerimeter(t, rectW, rectH, cornerR);
    const x = rectX0 + pt.x;
    const y = rectY0 + pt.y;

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (isMe ? ' me' : '');
    tag.textContent = p.name;
    tag.style.left = `${x}%`;
    tag.style.top  = `${y}%`;

    const spec = state.crystals?.[p.id];
    const crystal = document.createElement('div');
    crystal.className = 'tag-crystal';
    crystal.innerHTML = crystalSVG(spec, 18);
    tag.appendChild(crystal);

    tag.onclick = () => {
      if (p.id === state.userId) return;
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      pendingSeatIndexToSteal = p.seatIndex;
      pendingSeatPlayerIdToSteal = p.id;
      kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
      kickDialog.classList.remove('hidden');
    };

    const count = getHandCount(state.hands[p.id]);
    if (!isMe && count > 0){
      const miniHand = document.createElement('div');
      miniHand.className = 'mini-hand';
      const show = Math.min(3, count);
      for(let i=0;i<show;i++){
        const card = document.createElement('div');
        card.className = 'mini-card';
        card.style.left = `${(show===1?22: (show===2? 18+i*10 : 14+i*10))}px`;
        card.textContent = '';
        miniHand.appendChild(card);
      }
      tag.appendChild(miniHand);
    }

    playerCircle.appendChild(tag);
  }

  for(let i=0;i<N;i++){
    const p = players[i];
    const t = (i * step + offset) % 1;
    placePlayer(p, t, p.id === state.userId);
  }

  const meEl = playerCircle.querySelector('.player-tag.me');
  if(meEl){
    const pt = pointOnRoundedRectPerimeter(anchor, rectW, rectH, cornerR);
    const x = rectX0 + pt.x;
    const y = rectY0 + pt.y;
    meEl.style.left = `${x}%`;
    meEl.style.top  = `${y}%`;
  }
}

kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し' });

  if (pendingSeatPlayerIdToSteal) {
    await transferSeatAssets(pendingSeatPlayerIdToSteal, state.userId);
  }

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;
  await ensureCrystalForPlayer(state.userId);

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
  seatPop.classList.add('hidden');
});

/* 配布 & お題 */
async function dealInitialHandsAndTopic(){
  if (!state.roomCode) return;

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};
  const dealN = normDealCount(roomData?.topicControls?.dealCount ?? 1);

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};

  const playerIds = [];
  for (const seatIndex of Object.keys(tables)) {
    const t = tables[seatIndex];
    if (!t || !t.playerId) continue;
    playerIds.push(t.playerId);
  }
  if(!playerIds.length) return;

  const nums = Array.from({length:100}, (_,i)=>i+1);
  for(let i=nums.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [nums[i], nums[j]] = [nums[j], nums[i]];
  }

  const hands = {};
  playerIds.forEach((pid, idx) => {
    const start = idx * dealN;
    hands[pid] = { cards: nums.slice(start, start + dealN) };
  });

  const topicText = pickRandom(TOPIC_POOL);

  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/hands`), hands),
    remove(ref(db, `rooms/${state.roomCode}/fieldCards`)),
    remove(ref(db, `rooms/${state.roomCode}/notes`)),
    update(ref(db, `rooms/${state.roomCode}`), {
      revealStarted: false,
      dealCountAtStart: dealN,
      topic: { text: topicText, at: Date.now() }
    })
  ]);
}

hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => { startPop.classList.add('hidden'); });

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  await dealInitialHandsAndTopic();
  startPop.classList.add('hidden');
});

btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/fieldCards`)),
    remove(ref(db, `${base}/crystals`)),
    remove(ref(db, `${base}/seed`)),
    remove(ref(db, `${base}/topic`)),
    remove(ref(db, `${base}/notes`)),
    remove(ref(db, `${base}/dealCountAtStart`)),
    remove(ref(db, `${base}/helpTopics`)), // ✅ 追加：リセットでヘルプお題もシャッフルされるように
    update(ref(db, `${base}`), {
      revealStarted:false,
      topicControls: { hearts:[1,1,1], dealCount:1 }
    })
  ]);

  // ✅ リセット直後に新しい30枚を作成（＝「リセットを押したらヘルプタブのお題はシャッフル」）
  await reshuffleHelpTopics();

  state.seatedTable = null;
  startPop.classList.add('hidden');
  await syncSeatUI();
});
</script>

</body>
</html>
