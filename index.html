ネームタグ、他プレイヤーの手札カード、だけはチッププールよりも前レイヤーにしたい。でも、チップが触れなくならないように注意して。

<!DOCTYPE html> 
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>テンプレ</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:160;} /* ★追加：プールより前へ */
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('maemain.jpg'); }
  main.joined{ background-image:url('maingazo.jpg'); }

  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  .player-circle{
    position:relative;
    width:320px;
    height:320px;
    margin:20px auto 0;border-radius:50%;
    box-sizing:border-box;
    border:3px solid #000;
    z-index:170; /* ★追加：チッププールより前に */
  }
  .player-circle::before{content:'';}

  .player-wrap{
    position:absolute;
    transform:translate(-50%,-50%);
    display:flex;
    align-items:center;
    gap:6px;
    z-index:170; /* ★追加 */
  }

  .player-tag{
    position:relative;
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
  }
  .player-tag.me{ background:#111;color:#fff;border-color:#111; }

  /* ★追加：公開ターンの強調（現在の番） */
  .player-tag.turn{
    outline:2px solid #16a34a;
    outline-offset:2px;
  }
  .player-tag.me.turn{
    cursor:pointer;
  }
  .player-tag.me.turn::after{
    content:'公開';
    margin-left:6px;
    font-size:10px;
    font-weight:900;
    padding:1px 6px;
    border-radius:999px;
    background:rgba(22,163,74,.18);
    color:#eafff2;
    border:1px solid rgba(22,163,74,.35);
  }

  .owncircle{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:var(--oc-w, 44px);
    height:var(--oc-h, 44px);
    border-radius:999px;
    border:2px solid #000;
    pointer-events:none;
    z-index:-1;
  }
  .owncircle.hidden{ display:none; }

  .player-tag .mini-hand{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,3px);
    width:60px;height:30px;pointer-events:none;
    z-index:500; /* ★追加：プールより上 */
  }
  .player-tag .mini-card{
    position:absolute;left:50%;top:0;width:16px;height:22px;
    border-radius:4px;border:1px solid #bbb;
    background:linear-gradient(135deg,#e5e7eb,#cbd5f5);
    font-size:10px;display:flex;align-items:center;justify-content:center;
    transform-origin:bottom center;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
  }

  /* ★追加：公開手札（まっすぐ横一列） */
  .player-tag .reveal-hand{
    position:absolute;
    left:50%;
    top:100%;
    transform:translate(-50%,6px);
    display:flex;
    gap:4px;
    pointer-events:none;
    z-index:500; /* ★追加：プールより上 */
  }
  .reveal-card{
    width:34px;
    height:52px;
  }
  .reveal-card .pcard,
  .reveal-card .backcard{
    width:100% !important;
    height:100% !important;
    border-radius:6px !important;
  }
  .reveal-card .pcard .corner .rank{ font-size:7px !important; }
  .reveal-card .pcard .corner .suit{ font-size:7px !important; }
  .reveal-card .pcard .pip{ font-size:9px !important; }
  .reveal-card .pcard[data-rank="A"] .pip{ font-size:18px !important; }
  .reveal-card .pcard .face-holder{ font-size:16px !important; }
  .reveal-card .pcard .face-suit{ font-size:13px !important; }

  :root{ --chip-d: 24px; }
  .owned-chips{
    display:flex;
    align-items:center;
    gap:4px;
    min-height:var(--chip-d);
  }
  .owned-chip{
    width:var(--chip-d);
    height:var(--chip-d);
    border-radius:999px;
    overflow:hidden;
  }
  .owned-chip svg{ width:100%; height:100%; display:block; }

  .owned-chip.draggable{ cursor:grab; }
  .owned-chip.draggable:active{ cursor:grabbing; }

  .my-hand-wrapper{margin-top:16px;text-align:center;}
  .my-hand-title{display:none;}
  .my-hand{display:flex;justify-content:center;gap:8px;margin-top:6px;min-height:100px;}

  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}
  .role-row{display:flex;gap:12px;align-items:flex-start;padding:10px 0;}
  .role-card{
    width:72px;height:108px;border-radius:10px;border:1px solid #ddd;background:#f8f8f8;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    flex:0 0 auto;display:flex;align-items:center;justify-content:center;
    font-size:12px;font-weight:700;color:#444;
  }
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:900;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}

  .center-table{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    display:flex; align-items:center; gap:10px;
    pointer-events:none;
  }

  .deck-stack{
    width:54px;height:78px;
    position:relative;
    border-radius:10px;
    pointer-events:auto;
    cursor:pointer;
  }
  .deck-stack.empty{
    outline:1px dashed rgba(255,255,255,.45);
    outline-offset:-4px;
    background:rgba(20,20,20,.22);
    box-shadow:none;
  }
  .deck-layer{
    position:absolute; inset:0;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.65);
    box-shadow:none;
    overflow:hidden;
    background:
      radial-gradient(circle at 50% 50%, rgba(255,255,255,.18), rgba(255,255,255,0) 55%),
      repeating-linear-gradient(45deg, rgba(255,255,255,.10) 0 2px, rgba(255,255,255,0) 2px 6px),
      linear-gradient(135deg, rgba(185,28,28,.95), rgba(127,29,29,.95));
  }
  .deck-layer::after{
    content:'';
    position:absolute; inset:6px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,.45);
    box-shadow:inset 0 0 0 1px rgba(0,0,0,.15);
  }
  .deck-count{
    position:absolute; right:-6px; top:-8px;
    min-width:22px;height:18px;padding:0 6px;
    display:flex;align-items:center;justify-content:center;
    border-radius:999px;
    background:rgba(0,0,0,.55);
    color:#fff;font-size:11px;font-weight:900;
    text-shadow:none;
    border:1px solid rgba(255,255,255,.25);
    pointer-events:none;
  }

  .board-row{ display:flex; gap:8px; pointer-events:auto; }

  .board-slot{
    width:48px;height:72px;
    border-radius:10px;
    border:none;
    background:transparent;
    box-shadow:none;
    backdrop-filter:none;
    display:flex;align-items:center;justify-content:center;
    position:relative;
    overflow:visible;
    pointer-events:auto;
  }
  .board-slot.has-card{ cursor:pointer; }

  .pcard{
    width:60px;height:90px;
    border-radius:8px;
    border:1px solid #ddd;
    background:#fff;
    box-shadow:0 4px 12px rgba(0,0,0,.15);
    position:relative;
    overflow:hidden;
    user-select:none;
  }
  .pcard.red{ color:#c1121f; }
  .pcard.black{ color:#111; }

  .pcard .corner{
    position:absolute;
    display:flex;flex-direction:column;align-items:center;
    font-weight:900;
    line-height:1;
    gap:0px;
  }
  .pcard .corner .rank{ font-size:10px; }
  .pcard .corner .suit{ font-size:10px; transform:translateY(-1px); }
  .pcard .corner.tl{ left:3px; top:3px; }
  .pcard .corner.br{ right:3px; bottom:3px; transform:rotate(180deg); }

  .pcard .pips{
    position:absolute;
    left:10px; right:10px;
    top:16px; bottom:16px;
  }
  .pcard .pip{
    position:absolute;
    transform:translate(-50%,-50%);
    font-weight:900;
    font-size:12px;
  }
  .pcard .pip.flip{ transform:translate(-50%,-50%) rotate(180deg); }
  .pcard[data-rank="A"] .pip{ font-size:26px; }

  .pcard .face-holder{
    position:absolute; inset:14px 10px;
    border-radius:8px;
    display:flex;align-items:center;justify-content:center;
    font-weight:1000;
    font-size:28px;
    opacity:.20;
    letter-spacing:.02em;
  }
  .pcard .face-suit{
    position:absolute;
    left:50%; top:52%;
    transform:translate(-50%,-50%);
    font-size:22px;
    opacity:.35;
    font-weight:900;
  }

  .my-card{ width:60px;height:90px; }

  .backcard{
    width:60px;height:90px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,.65);
    overflow:hidden;
    position:relative;
    background:
      radial-gradient(circle at 50% 50%, rgba(255,255,255,.18), rgba(255,255,255,0) 55%),
      repeating-linear-gradient(45deg, rgba(255,255,255,.10) 0 2px, rgba(255,255,255,0) 2px 6px),
      linear-gradient(135deg, rgba(185,28,28,.95), rgba(127,29,29,.95));
    box-shadow:0 4px 12px rgba(0,0,0,.15);
  }
  .backcard::after{
    content:'';
    position:absolute;
    inset:6px;
    border-radius:6px;
    border:1px solid rgba(255,255,255,.45);
    box-shadow:inset 0 0 0 1px rgba(0,0,0,.15);
  }

  .board-slot .pcard,
  .board-slot .backcard{
    width:48px !important;
    height:72px !important;
  }

  .fly-card{
    position:fixed;
    width:60px;height:90px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,.65);
    overflow:hidden;
    z-index:9999;
    pointer-events:none;
    background:
      radial-gradient(circle at 50% 50%, rgba(255,255,255,.18), rgba(255,255,255,0) 55%),
      repeating-linear-gradient(45deg, rgba(255,255,255,.10) 0 2px, rgba(255,255,255,0) 2px 6px),
      linear-gradient(135deg, rgba(185,28,28,.95), rgba(127,29,29,.95));
  }
  .fly-card::after{
    content:'';
    position:absolute; inset:6px;
    border-radius:6px;
    border:1px solid rgba(255,255,255,.45);
    box-shadow:inset 0 0 0 1px rgba(0,0,0,.15);
  }

  .chip-pool{
    position:fixed;
    right:12px;
    top:68px;
    width:130px;
    height:200px;
    background:rgba(255,255,255,.92);
    backdrop-filter: blur(6px);
    border:2px solid #000;
    border-radius:16px;
    box-shadow:none;
    z-index:200; /* ★変更：手札(170/500)より後ろへ */
    overflow:hidden;
    display:flex;
    flex-direction:column;
    pointer-events:auto;
  }
  .chip-pool.hidden{ display:none; }
  .chip-pool-header{ display:none; }
  .chip-pool-area{
    position:relative;
    flex:1 1 auto;
    overflow:hidden;
  }
  .chip-item{
    position:absolute;
    width:var(--chip-d);
    height:var(--chip-d);
    border-radius:999px;
    touch-action:none;
    cursor:grab;
    user-select:none;
  }
  .chip-item.dragging{ cursor:grabbing; }
  .chip-item svg{ width:100%; height:100%; display:block; }

  .chip-floating{
    position:fixed;
    left:0; top:0;
    z-index:10000;
    pointer-events:none;
  }

  #dragLayer{
    position:fixed; inset:0;
    z-index:9999;
    pointer-events:none;
  }
</style>
</head>
<body>

<header>
  <h1>テンプレ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">リンクコピー</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle">
      <div id="centerTable" class="center-table">
        <div id="deckStack" class="deck-stack empty" title="山札">
          <div id="deckCount" class="deck-count">52</div>
        </div>
        <div id="boardRow" class="board-row" aria-label="場札">
          <div class="board-slot" data-slot="0"></div>
          <div class="board-slot" data-slot="1"></div>
          <div class="board-slot" data-slot="2"></div>
          <div class="board-slot" data-slot="3"></div>
          <div class="board-slot" data-slot="4"></div>
        </div>
      </div>
    </div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>
      <div id="myHand" class="my-hand"></div>
    </div>
  </div>
</main>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>
<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<div id="chipPool" class="chip-pool hidden" aria-label="チッププール">
  <div class="chip-pool-header">
    <div class="chip-pool-title"></div>
    <div class="chip-pool-sub" id="chipPoolSub"></div>
  </div>
  <div id="chipPoolArea" class="chip-pool-area"></div>
</div>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で山札(52)を生成し、全プレイヤーへ2枚ずつ配布。<br>
    場札は最初0枚です。山札クリックで「裏3枚→場札クリックで順に表→山札で最大5枚」。
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<div id="dragLayer"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, set, get, update, onValue, remove } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qOQ2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:2986... (省略せずに入れてOK)",
  measurementId: "G-HPDFTCLR8H"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hands: {},
  room: {},
  game: { started:false, deck: [], boardCodes: [], boardFaceUpCount: 0, deal:null },

  dealing: false,
  dealShownCounts: null,

  chipOwners: {},
  chipPoolPos: {},
  chipFaceDown: {},

  ownCircleVisible: true,

  /* ★追加：公開フェーズ（DB: rooms/{room}/reveal） */
  reveal: null
};

const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const chipPool = document.getElementById('chipPool');
const chipPoolArea = document.getElementById('chipPoolArea');
const dragLayer = document.getElementById('dragLayer');

const ROLE_HELP = [
  { name: "カード1", text: "ああああ" },
  { name: "カード2", text: "いいいい" },
  { name: "カード3", text: "うううう" },
  { name: "カード4", text: "うううう" },
];

function renderHelpList(){
  helpBody.innerHTML = '';
  ROLE_HELP.forEach((r, idx) => {
    const row = document.createElement('div');
    row.className = 'role-row';

    const card = document.createElement('div');
    card.className = 'role-card';
    card.textContent = `CARD ${idx+1}`;

    const desc = document.createElement('div');
    desc.className = 'role-desc';
    desc.innerHTML = `
      <div class="name">${r.name}</div>
      <div class="text">${r.text}</div>
    `;

    row.appendChild(card);
    row.appendChild(desc);
    helpBody.appendChild(row);
  });
}
function openHelp(){
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
}
function closeHelp(){
  helpBackdrop.classList.add('hidden');
}
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => {
  if (e.target === helpBackdrop) closeHelp();
});

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;
let latestPlayers = [];

let isDealAnimating = false;
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

/* =========================
   ★ 公開フェーズ（赤チップ全消え→赤★1→★2→…）
   ========================= */
function getMaxPlayers(){
  const n = Number(state.room?.maxPlayers || 0);
  return Number.isFinite(n) ? n : 0;
}
function allRedChipIds(n){
  const out = [];
  for (let i=1; i<=n; i++) out.push(`赤_${i}`);
  return out;
}
function getRevealCurrentPid(){
  const r = state.reveal;
  if (!r || !r.active || !Array.isArray(r.order)) return null;
  const t = Number(r.turn || 0);
  return r.order[t] || null;
}
function isMyRevealTurn(){
  const cur = getRevealCurrentPid();
  if (!cur) return false;
  if (cur !== state.userId) return false;
  if (state.reveal?.revealed?.[state.userId]) return false;
  return true;
}
async function revealMyHand(){
  if (!state.roomCode) return;
  if (!isMyRevealTurn()) return;

  const revealRef = ref(db, `rooms/${state.roomCode}/reveal`);
  const snap = await get(revealRef);
  const r = snap.val();
  if (!r || !r.active || !Array.isArray(r.order)) return;

  const order = r.order;
  const turn = Number(r.turn || 0);
  const curPid = order[turn];
  if (curPid !== state.userId) return;

  const revealed = r.revealed || {};
  if (revealed[state.userId]) return;

  revealed[state.userId] = true;

  let next = turn + 1;
  while (next < order.length && revealed[order[next]]) next++;

  const patch = { revealed };
  if (next >= order.length){
    patch.active = false;
    patch.turn = order.length;
    patch.endedAt = Date.now();
  } else {
    patch.turn = next;
  }

  await update(revealRef, patch);
}

let _startingReveal = false;
async function maybeStartRevealPhaseIfReady(){
  if (_startingReveal) return;
  if (!state.isHost || !state.roomCode) return;

  const n = getMaxPlayers();
  if (!n) return;

  const revealRef = ref(db, `rooms/${state.roomCode}/reveal`);
  const curSnap = await get(revealRef);
  const cur = curSnap.val();
  if (cur && cur.startedAt) return;

  const owners = state.chipOwners || {};
  const redIds = allRedChipIds(n);
  const unowned = redIds.filter(id => !owners[id]);
  if (unowned.length > 0) return;

  _startingReveal = true;
  try{
    const entries = [];
    redIds.forEach(id => {
      const owner = owners[id];
      if (!owner) return;
      const parts = String(id).split('_');
      const i = Number(parts[1] || 0);
      const stars = ((i - 1) % 6) + 1;
      entries.push({ owner, stars, i });
    });
    entries.sort((a,b) => (a.stars - b.stars) || (a.i - b.i));

    const seen = new Set();
    const order = [];
    for (const e of entries){
      if (!e.owner) continue;
      if (seen.has(e.owner)) continue;
      seen.add(e.owner);
      order.push(e.owner);
    }

    if (!order.length) return;

    await set(revealRef, {
      active: true,
      order,
      turn: 0,
      revealed: {},
      startedAt: Date.now()
    });
  } finally {
    _startingReveal = false;
  }
}

myHandEl.addEventListener('click', () => {
  if (isMyRevealTurn()) revealMyHand();
});

function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');

  chipPool.classList.toggle('hidden', joinBox.classList.contains('hidden') ? false : true);
}

function setOwnCircleVisible(visible){
  state.ownCircleVisible = !!visible;
  const oc = document.getElementById('ownCircle');
  if (oc){
    oc.classList.toggle('hidden', !state.ownCircleVisible);
  }
}

function updateOwnCircleToFit(){
  const wrap = document.querySelector(`.player-wrap[data-pid="${state.userId}"]`);
  if (!wrap) return;
  const oc = wrap.querySelector('#ownCircle');
  if (!oc) return;

  const pad = 18;
  const w = Math.max(20, wrap.offsetWidth + pad);
  const h = Math.max(20, wrap.offsetHeight + pad);

  oc.style.setProperty('--oc-w', `${Math.round(w)}px`);
  oc.style.setProperty('--oc-h', `${Math.round(h)}px`);
  oc.classList.toggle('hidden', !state.ownCircleVisible);
}
window.addEventListener('resize', () => requestAnimationFrame(updateOwnCircleToFit));

/* =========================
   ★ チップSVG（裏向き対応）
   ========================= */
const CHIP_COLORS = [
  { key:"白", fill:"#F7F7F7", stroke:"#CFCFCF" },
  { key:"黄", fill:"#FFD84A", stroke:"#C9A600" },
  { key:"オレンジ", fill:"#FF9A2F", stroke:"#D06B00" },
  { key:"赤", fill:"#FF4B4B", stroke:"#C82828" },
];
const CHIP_COLOR_MAP = Object.fromEntries(CHIP_COLORS.map(c => [c.key, c]));

const toRad = d => d * Math.PI / 180;
function polar(cx, cy, r, angRad){
  return { x: cx + Math.cos(angRad)*r, y: cy + Math.sin(angRad)*r };
}
function starPolygonPoints(cx, cy, outerR, innerR, spikes = 5, rotationDeg = -90){
  const pts = [];
  const rot = rotationDeg * Math.PI / 180;
  const step = Math.PI / spikes;
  for(let i=0;i<spikes*2;i++){
    const r = (i % 2 === 0) ? outerR : innerR;
    const a = rot + i * step;
    pts.push((cx + Math.cos(a)*r).toFixed(2) + "," + (cy + Math.sin(a)*r).toFixed(2));
  }
  return pts.join(" ");
}
function starPositionsInsideCircle(cx, cy, n, ringR){
  if(n === 1) return [{ x: cx, y: cy }];
  const pos = [];
  const startDeg = -90;
  for(let i=0;i<n;i++){
    const a = (startDeg + (360/n)*i) * Math.PI/180;
    pos.push({ x: cx + Math.cos(a)*ringR, y: cy + Math.sin(a)*ringR });
  }
  return pos;
}
function spokeSectorsData(cx, cy, rInnerEdge, rOuterEdge, spokeThickness, stepDeg = 60, startDeg = -90){
  const midR = (rInnerEdge + rOuterEdge) / 2;
  const halfW = spokeThickness / 2;

  let halfAngle = Math.asin(Math.min(1, halfW / Math.max(1e-6, midR)));
  halfAngle = Math.min(halfAngle, Math.PI/2 - 1e-3);

  const out = [];
  let idx = 0;
  for(let deg = startDeg; deg < startDeg + 360; deg += stepDeg){
    const a = toRad(deg);
    const a1 = a - halfAngle;
    const a2 = a + halfAngle;

    const pIn1  = polar(cx, cy, rInnerEdge, a1);
    const pOut1 = polar(cx, cy, rOuterEdge, a1);
    const pOut2 = polar(cx, cy, rOuterEdge, a2);
    const pIn2  = polar(cx, cy, rInnerEdge, a2);

    const d = [
      `M ${pIn1.x.toFixed(2)} ${pIn1.y.toFixed(2)}`,
      `L ${pOut1.x.toFixed(2)} ${pOut1.y.toFixed(2)}`,
      `A ${rOuterEdge.toFixed(2)} ${rOuterEdge.toFixed(2)} 0 0 1 ${pOut2.x.toFixed(2)} ${pOut2.y.toFixed(2)}`,
      `L ${pIn2.x.toFixed(2)} ${pIn2.y.toFixed(2)}`,
      `A ${rInnerEdge.toFixed(2)} ${rInnerEdge.toFixed(2)} 0 0 0 ${pIn1.x.toFixed(2)} ${pIn1.y.toFixed(2)}`,
      `Z`
    ].join(" ");

    out.push({ d, angle: a, idx });
    idx++;
  }
  return out;
}
function markerOffsets(lineCount, spokeThickness){
  if(lineCount <= 0) return [];
  const spread = spokeThickness * 0.25;
  if(lineCount === 1) return [0];
  if(lineCount === 2) return [-spread * 0.75, spread * 0.75];
  return [-spread, 0, spread];
}
function markerLinesMarkup(spokesData, cx, cy, rInnerEdge, rOuterEdge, spokeThickness, lineCount, lineColor, clipId){
  if(lineCount <= 0) return "";
  const offsets = markerOffsets(lineCount, spokeThickness);
  const sw = 2.2;

  const segs = [];
  for(const sp of spokesData){
    const a = sp.angle;
    for(const t of offsets){
      const daIn  = t / rInnerEdge;
      const daOut = t / rOuterEdge;

      const pIn  = polar(cx, cy, rInnerEdge, a + daIn);
      const pOut = polar(cx, cy, rOuterEdge, a + daOut);

      segs.push(
        `<path d="M ${pIn.x.toFixed(2)} ${pIn.y.toFixed(2)} L ${pOut.x.toFixed(2)} ${pOut.y.toFixed(2)}"
           fill="none" stroke="${lineColor}" stroke-width="${sw}"
           stroke-linecap="round" stroke-linejoin="round" />`
      );
    }
  }

  return `<g clip-path="url(#${clipId})">${segs.join("")}</g>`;
}

function chipSVG(color, stars, uid, faceDown = false){
  const { key, fill, stroke } = color;
  const vb = 100;
  const cx = 50, cy = 50;

  const outerR = 46;
  const outerStroke = 4;

  const innerCircleR = 33;
  const innerStroke = 2.2;

  const spokeThickness = 16;

  const rInnerEdge = innerCircleR + innerStroke/2;
  const rOuterEdge = outerR - outerStroke/2;

  const starOuter = 6.0;
  const starInner = 2.6;
  const starRingR = 12;

  const maxRingR = Math.max(0, innerCircleR - (starOuter + 4 + innerStroke));
  const ringR = Math.min(starRingR, maxRingR);

  const starPts = starPolygonPoints(0, 0, starOuter, starInner);
  const positions = starPositionsInsideCircle(cx, cy, stars, ringR);

  const spokesData = spokeSectorsData(cx, cy, rInnerEdge, rOuterEdge, spokeThickness, 60, -90);
  const spokesMarkup = spokesData.map(s => `<path d="${s.d}" fill="#111" />`).join("");

  const lineCount =
    (key === "黄") ? 1 :
    (key === "オレンジ") ? 2 :
    (key === "赤") ? 3 : 0;

  const clipId = `spokes-clip-${uid}`;
  const coloredLines = markerLinesMarkup(
    spokesData, cx, cy, rInnerEdge, rOuterEdge, spokeThickness,
    lineCount, fill, clipId
  );

  const shadow = `
    <filter id="ds-${uid}" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="0" dy="1.2" stdDeviation="1.2" flood-color="#000" flood-opacity=".15"/>
    </filter>
  `;

  const starFill = faceDown ? fill : "#111";
  const starsMarkup = positions.map(p => (
    `<polygon points="${starPts}" fill="${starFill}" transform="translate(${p.x.toFixed(2)} ${p.y.toFixed(2)})" />`
  )).join("");

  const innerFill = faceDown ? "#111" : "none";

  return `
    <svg viewBox="0 0 ${vb} ${vb}" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="チップ">
      <defs>
        ${shadow}
        <clipPath id="${clipId}">
          ${spokesData.map(s => `<path d="${s.d}"></path>`).join("")}
        </clipPath>
      </defs>

      <circle cx="${cx}" cy="${cy}" r="${outerR}" fill="${fill}" filter="url(#ds-${uid})"/>
      ${spokesMarkup}
      ${coloredLines}
      <circle cx="${cx}" cy="${cy}" r="${outerR}" fill="none" stroke="${stroke}" stroke-width="${outerStroke}"/>
      <circle cx="${cx}" cy="${cy}" r="${innerCircleR}" fill="${innerFill}" stroke="#111" stroke-width="${innerStroke}"/>
      ${starsMarkup}
    </svg>
  `;
}

/* =========================
   ★ チッププール生成
   ========================= */
let chipUid = 0;
let chipState = {
  builtFor: null,
  chips: [],
  draggingId: null,
  dragOffX: 0,
  dragOffY: 0,
  raf: 0,
  dragMeta: {},
  press: null,
  lastTap: {}
};

const DOUBLE_TAP_MS = 320;
const TAP_SLOP_PX   = 6;
const DRAG_START_PX = 7;

function getChipD(){
  const v = getComputedStyle(document.documentElement).getPropertyValue('--chip-d').trim();
  const n = Number(String(v).replace('px',''));
  return Number.isFinite(n) && n > 6 ? n : 24;
}
function setChipDFromTag(){
  const tag = document.querySelector('.player-tag');
  if (!tag) return;
  const h = tag.getBoundingClientRect().height;
  if (h && h > 10){
    document.documentElement.style.setProperty('--chip-d', `${Math.round(h)}px`);
  }
}
function clamp(v, min, max){
  return Math.max(min, Math.min(max, v));
}
function getChipById(id){
  return chipState.chips.find(c => c.id === id) || null;
}
function buildChipSetForPlayers(playerCount){
  const n = Math.max(0, Number(playerCount || 0));
  const chips = [];
  for (let i=1; i<=n; i++){
    const stars = ((i - 1) % 6) + 1;
    for (const c of CHIP_COLORS){
      chips.push({
        id: `${c.key}_${i}`,
        colorKey: c.key,
        stars,
        color: c
      });
    }
  }
  return chips;
}
function layoutChipPositions(chips){
  const d = getChipD();
  const gap = Math.max(2, Math.round(d * 0.18));
  const pad = 10;

  const rect = chipPoolArea.getBoundingClientRect();
  const W = rect.width;
  const H = rect.height;

  const cols = 4;
  chips.forEach((ch, idx) => {
    const col = idx % cols;
    const row = Math.floor(idx / cols);

    const x = pad + col * (d + gap);
    const y = pad + row * (d + gap);

    ch.x = clamp(x, 0, W - d);
    ch.y = clamp(y, 0, H - d);
  });
}
function applyChipTransform(ch){
  if (!ch.el) return;
  ch.el.style.transform = `translate(${ch.x}px, ${ch.y}px)`;
}
function attachChipToPool(ch){
  if (!ch?.el) return;
  if (ch.el.parentNode !== chipPoolArea) chipPoolArea.appendChild(ch.el);
  ch.el.classList.remove('chip-floating');
  ch.el.style.position = 'absolute';
  ch.el.style.left = '';
  ch.el.style.top  = '';
  ch.el.style.transform = `translate(${ch.x}px, ${ch.y}px)`;
  ch.el.style.zIndex = '';
  ch.el.style.pointerEvents = 'auto';
}
function attachChipToDragLayer(ch){
  if (!ch?.el) return;
  if (ch.el.parentNode !== dragLayer) dragLayer.appendChild(ch.el);
  ch.el.classList.add('chip-floating');
  ch.el.style.position = 'fixed';
  ch.el.style.transform = '';
  ch.el.style.zIndex = '10000';
  ch.el.style.pointerEvents = 'none';
}
function isPointInRect(x, y, r){
  return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
}

/* ★ owncircle 当たり判定（楕円） */
function isPointInOwnCircle(x, y){
  const oc = document.getElementById('ownCircle');
  if (!oc || oc.classList.contains('hidden')) return false;
  const r = oc.getBoundingClientRect();
  const cx = r.left + r.width/2;
  const cy = r.top  + r.height/2;
  const rx = Math.max(1, r.width/2);
  const ry = Math.max(1, r.height/2);
  const dx = (x - cx) / rx;
  const dy = (y - cy) / ry;
  return (dx*dx + dy*dy) <= 1;
}

function applyChipOwnersToPool(){
  const owners = state.chipOwners || {};
  chipState.chips.forEach(ch => {
    const owner = owners[ch.id];
    if (owner){
      ch.el.style.display = 'none';
    } else {
      ch.el.style.display = '';
    }
  });
}
function applyChipFacesToPool(){
  if (!chipState.chips.length) return;
  chipState.chips.forEach(ch => {
    if (state.chipOwners && state.chipOwners[ch.id]) return;
    if (chipState.draggingId === ch.id) return;
    const fd = !!state.chipFaceDown?.[ch.id];
    if (ch.faceDown === fd) return;
    ch.faceDown = fd;
    chipUid++;
    if (ch.el) ch.el.innerHTML = chipSVG(ch.color, ch.stars, chipUid, fd);
  });
}

/* ★ 所有チップ描画など */
function parseChipId(chipId){
  const [colorKey, numStr] = String(chipId || '').split('_');
  const n = Number(numStr || 0);
  const color = CHIP_COLOR_MAP[colorKey] || CHIP_COLORS[0];
  const stars = ((n - 1) % 6) + 1;
  return { colorKey, n, stars, color };
}

/* ====== ★変更：所持チップの並びを「色順 白→黄→オレンジ→赤」優先に ====== */
function chipSortKey(chipId){
  const { colorKey, n } = parseChipId(chipId);
  const colorOrder = { "白":0, "黄":1, "オレンジ":2, "赤":3 };
  return [colorOrder[colorKey] ?? 9, n].join('_');
}

let ownedDrag = null;

/* ====== ★追加：チップをプールへ返却（owner解除） ====== */
async function returnChipToPool(chipId){
  if (!state.roomCode) return;
  try{
    await remove(ref(db, `rooms/${state.roomCode}/chipOwners/${chipId}`));
  }catch(e){}
}

function startOwnedChipDrag(e, chipId){
  e.preventDefault();
  e.stopPropagation();

  if (!state.roomCode) return;
  const curOwner = state.chipOwners?.[chipId];
  if (!curOwner) return;

  const srcEl = e.currentTarget;
  if (!srcEl) return;

  const r = srcEl.getBoundingClientRect();
  const ghost = document.createElement('div');
  ghost.className = 'chip-item chip-floating';
  ghost.style.width = `var(--chip-d)`;
  ghost.style.height = `var(--chip-d)`;
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.pointerEvents = 'none';
  ghost.style.zIndex = '10000';
  ghost.innerHTML = srcEl.innerHTML;

  dragLayer.appendChild(ghost);

  srcEl.style.visibility = 'hidden';

  ownedDrag = {
    chipId,
    srcEl,
    ghost,
    offX: e.clientX - r.left,
    offY: e.clientY - r.top
  };

  const onMove = (ev) => {
    if (!ownedDrag) return;
    ev.preventDefault();
    const left = ev.clientX - ownedDrag.offX;
    const top  = ev.clientY - ownedDrag.offY;
    ownedDrag.ghost.style.left = `${left}px`;
    ownedDrag.ghost.style.top  = `${top}px`;
  };

  const onUp = async (ev) => {
    if (!ownedDrag) return;
    ev.preventDefault();

    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);
    window.removeEventListener('pointercancel', onUp);

    const { chipId, srcEl, ghost } = ownedDrag;

    const droppedInOwn = isPointInOwnCircle(ev.clientX, ev.clientY);

    if (ghost && ghost.parentNode) ghost.remove();
    if (srcEl && srcEl.isConnected) srcEl.style.visibility = '';

    ownedDrag = null;

    if (droppedInOwn){
      try{
        await set(ref(db, `rooms/${state.roomCode}/chipOwners/${chipId}`), state.userId);
      }catch(e2){}
    } else {
      await returnChipToPool(chipId);
    }
  };

  window.addEventListener('pointermove', onMove, { passive:false });
  window.addEventListener('pointerup', onUp, { passive:false });
  window.addEventListener('pointercancel', onUp, { passive:false });
}

function renderOwnedChips(){
  const wraps = playerCircle.querySelectorAll('.player-wrap');
  if (!wraps.length) return;

  const owners = state.chipOwners || {};
  const byPlayer = {};
  for (const [chipId, pid] of Object.entries(owners)){
    if (!pid) continue;
    (byPlayer[pid] ||= []).push(chipId);
  }
  for (const pid in byPlayer){
    byPlayer[pid].sort((a,b) => chipSortKey(a).localeCompare(chipSortKey(b)));
  }

  wraps.forEach(w => {
    const pid = w.dataset.pid;
    const box = w.querySelector('.owned-chips');
    if (!box) return;
    box.innerHTML = '';

    const list = byPlayer[pid] || [];
    list.forEach(chipId => {
      const { color, stars } = parseChipId(chipId);
      const fd = !!state.chipFaceDown?.[chipId];

      chipUid++;
      const el = document.createElement('div');
      el.className = 'owned-chip draggable';
      el.dataset.chipId = chipId;
      el.innerHTML = chipSVG(color, stars, chipUid, fd);

      el.addEventListener('pointerdown', (e) => startOwnedChipDrag(e, chipId), { passive:false });
      box.appendChild(el);
    });
  });

  requestAnimationFrame(updateOwnCircleToFit);
}

async function claimChip(chipId){
  if (!state.roomCode) return false;
  const oneRef = ref(db, `rooms/${state.roomCode}/chipOwners/${chipId}`);
  const snap = await get(oneRef);
  if (snap.exists() && snap.val()) return false;

  await set(oneRef, state.userId);
  return true;
}

async function toggleChipFaceDown(chipId){
  if (!state.roomCode) return;
  if (state.chipOwners && state.chipOwners[chipId]) return;
  const cur = !!state.chipFaceDown?.[chipId];
  try{
    await set(ref(db, `rooms/${state.roomCode}/chipFaceDown/${chipId}`), !cur);
  }catch(e){}
}

/* =========================
   ★ チッププール位置同期
   ========================= */
let chipPosCommitTimer = 0;
function scheduleCommitChipPoolPos(){
  if (!state.roomCode) return;
  if (chipPosCommitTimer) return;
  chipPosCommitTimer = setTimeout(() => {
    chipPosCommitTimer = 0;
    commitChipPoolPosAll();
  }, 80);
}
async function commitChipPoolPosAll(){
  if (!state.roomCode) return;
  if (!chipState.chips.length) return;

  const rect = chipPoolArea.getBoundingClientRect();
  const d = getChipD();
  const W = rect.width, H = rect.height;

  const payload = {};
  chipState.chips.forEach(ch => {
    if (state.chipOwners && state.chipOwners[ch.id]) return;
    payload[ch.id] = {
      x: clamp(Math.round(ch.x), 0, Math.max(0, W - d)),
      y: clamp(Math.round(ch.y), 0, Math.max(0, H - d)),
      updatedAt: Date.now(),
      updatedBy: state.userId
    };
  });

  try{
    await update(ref(db, `rooms/${state.roomCode}/chipPoolPos`), payload);
  }catch(e){}
}
function applyChipPoolPosFromState(){
  if (!chipState.chips.length) return;

  const pos = state.chipPoolPos || {};
  const rect = chipPoolArea.getBoundingClientRect();
  const d = getChipD();
  const W = rect.width, H = rect.height;

  chipState.chips.forEach(ch => {
    const p = pos[ch.id];
    if (!p) return;
    if (chipState.draggingId === ch.id) return;

    const nx = clamp(Number(p.x), 0, Math.max(0, W - d));
    const ny = clamp(Number(p.y), 0, Math.max(0, H - d));
    if (!Number.isFinite(nx) || !Number.isFinite(ny)) return;

    ch.x = nx; ch.y = ny;
    attachChipToPool(ch);
    applyChipTransform(ch);
  });
}

/* =========================
   ★ プール内「押し出し」処理
   ========================= */
function resolveOverlaps(draggingId){
  const d = getChipD();
  const r = d / 2;

  const rect = chipPoolArea.getBoundingClientRect();
  const W = rect.width;
  const H = rect.height;

  const iters = 4;
  for (let t=0; t<iters; t++){
    for (let i=0; i<chipState.chips.length; i++){
      const a = chipState.chips[i];
      for (let j=i+1; j<chipState.chips.length; j++){
        const b = chipState.chips[j];

        if ((state.chipOwners && state.chipOwners[a.id]) || (state.chipOwners && state.chipOwners[b.id])) continue;

        const aIsDrag = (a.id === draggingId);
        const bIsDrag = (b.id === draggingId);

        let ax = a.x + r, ay = a.y + r;
        let bx = b.x + r, by = b.y + r;

        let dx = bx - ax;
        let dy = by - ay;

        let dist = Math.hypot(dx, dy);
        const minDist = d;

        if (dist === 0){
          dx = (Math.random() - 0.5) * 0.01;
          dy = (Math.random() - 0.5) * 0.01;
          dist = Math.hypot(dx, dy);
        }

        if (dist < minDist){
          const overlap = (minDist - dist);
          const nx = dx / dist;
          const ny = dy / dist;

          const pushA = bIsDrag ? overlap : (aIsDrag ? 0 : overlap/2);
          const pushB = aIsDrag ? overlap : (bIsDrag ? 0 : overlap/2);

          if (pushA){
            a.x -= nx * pushA;
            a.y -= ny * pushA;
          }
          if (pushB){
            b.x += nx * pushB;
            b.y += ny * pushB;
          }

          a.x = clamp(a.x, 0, W - d);
          a.y = clamp(a.y, 0, H - d);
          b.x = clamp(b.x, 0, W - d);
          b.y = clamp(b.y, 0, H - d);
        }
      }
    }
  }
}

/* =========================================================
   ★ ダブルクリックで裏返す
   ========================================================= */
function startChipDragNow(ch, rectArea){
  chipState.draggingId = ch.id;
  ch.el.classList.add('dragging');
  attachChipToDragLayer(ch);

  ch.el.style.left = `${rectArea.left + ch.x}px`;
  ch.el.style.top  = `${rectArea.top  + ch.y}px`;
}


function onChipPointerDown(e, chipId){
  e.preventDefault();
  e.stopPropagation();

  if (state.chipOwners && state.chipOwners[chipId]) return;

  const ch = getChipById(chipId);
  if (!ch || !ch.el) return;

  const rectArea = chipPoolArea.getBoundingClientRect();

  const chipLeftInView = rectArea.left + ch.x;
  const chipTopInView  = rectArea.top  + ch.y;
  const offX = e.clientX - chipLeftInView;
  const offY = e.clientY - chipTopInView;

  chipState.dragMeta[chipId] = {
    startX: ch.x,
    startY: ch.y,
    lastWallPos: { x: ch.x, y: ch.y }
  };

  chipState.press = {
    chipId,
    pointerId: e.pointerId,
    downX: e.clientX,
    downY: e.clientY,
    startedDrag: false,
    offX, offY
  };

  const onMove = (ev) => onChipPointerMove(ev);
  const onUp   = (ev) => onChipPointerUp(ev, onMove, onUp);

  window.addEventListener('pointermove', onMove, { passive:false });
  window.addEventListener('pointerup', onUp, { passive:false });
  window.addEventListener('pointercancel', onUp, { passive:false });
}

function onChipPointerMove(e){
  if (!chipState.press) return;

  e.preventDefault();

  const { chipId, downX, downY } = chipState.press;
  const ch = getChipById(chipId);
  if (!ch || !ch.el) return;

  const rectArea = chipPoolArea.getBoundingClientRect();
  const d = getChipD();
  const W = rectArea.width;
  const H = rectArea.height;

  const mx = e.clientX;
  const my = e.clientY;

if (!chipState.press.startedDrag){
  const dist = Math.hypot(mx - downX, my - downY);
  if (dist >= DRAG_START_PX){
    chipState.press.startedDrag = true;
    startChipDragNow(ch, rectArea); // ★ここ
  } else {
    return;
  }
}


  const inPool = isPointInRect(mx, my, rectArea);

  if (inPool){
    const px = mx - rectArea.left - chipState.press.offX;
    const py = my - rectArea.top  - chipState.press.offY;

    ch.x = clamp(px, 0, W - d);
    ch.y = clamp(py, 0, H - d);

    const inset = 2;
    const distL = ch.x;
    const distR = (W - d) - ch.x;
    const distT = ch.y;
    const distB = (H - d) - ch.y;
    const min = Math.min(distL, distR, distT, distB);

    let backX = ch.x, backY = ch.y;
    if (min === distL) backX = inset;
    else if (min === distR) backX = (W - d) - inset;
    else if (min === distT) backY = inset;
    else backY = (H - d) - inset;

    chipState.dragMeta[ch.id].lastWallPos = { x: clamp(backX,0,W-d), y: clamp(backY,0,H-d) };

    resolveOverlaps(ch.id);
    chipState.chips.forEach(c => {
      if (c.id !== ch.id) applyChipTransform(c);
    });

    ch.el.style.left = `${rectArea.left + ch.x}px`;
    ch.el.style.top  = `${rectArea.top  + ch.y}px`;

    scheduleCommitChipPoolPos();
  } else {
    const left = mx - chipState.press.offX;
    const top  = my - chipState.press.offY;
    ch.el.style.left = `${left}px`;
    ch.el.style.top  = `${top}px`;
  }
}

async function onChipPointerUp(e, onMove, onUp){
  if (!chipState.press) return;
  e.preventDefault();

  const press = chipState.press;
  chipState.press = null;

  window.removeEventListener('pointermove', onMove);
  window.removeEventListener('pointerup', onUp);
  window.removeEventListener('pointercancel', onUp);

  const chipId = press.chipId;
  const ch = getChipById(chipId);
  if (!ch || !ch.el) return;

  const rectArea = chipPoolArea.getBoundingClientRect();

  if (!press.startedDrag){
    const inPool = isPointInRect(e.clientX, e.clientY, rectArea);
    if (!inPool) return;

    const moved = Math.hypot(e.clientX - press.downX, e.clientY - press.downY);
    if (moved > 6) return;

    const last = chipState.lastTap[chipId];
    const now = Date.now();

    if (last && (now - last.at) <= 320){
      delete chipState.lastTap[chipId];
      await toggleChipFaceDown(chipId);
    } else {
      chipState.lastTap[chipId] = { at: now, x: e.clientX, y: e.clientY };
      setTimeout(() => {
        const cur = chipState.lastTap[chipId];
        if (cur && (Date.now() - cur.at) > 320) delete chipState.lastTap[chipId];
      }, 350);
    }
    return;
  }

  chipState.draggingId = null;
  ch.el.classList.remove('dragging');

  const d = getChipD();
  const left = Number(String(ch.el.style.left || '0').replace('px','')) || 0;
  const top  = Number(String(ch.el.style.top  || '0').replace('px','')) || 0;
  const cx = left + d/2;
  const cy = top  + d/2;

  const droppedInPool = isPointInRect(cx, cy, rectArea);
  const droppedInOwn = isPointInOwnCircle(cx, cy);

  if (droppedInOwn){
    const ok = await claimChip(ch.id);
    if (ok){
      const meta = chipState.dragMeta[ch.id] || { startX: ch.x, startY: ch.y };
      ch.x = meta.startX; ch.y = meta.startY;
      attachChipToPool(ch);
      ch.el.style.display = 'none';
      chipState.dragMeta[ch.id] = null;

      state.chipOwners = { ...(state.chipOwners||{}), [ch.id]: state.userId };
      applyChipOwnersToPool();
      renderOwnedChips();
      updateOwnCircleToFit();
      return;
    }
  }

  if (droppedInPool){
    const px = cx - rectArea.left - d/2;
    const py = cy - rectArea.top  - d/2;
    ch.x = clamp(px, 0, rectArea.width - d);
    ch.y = clamp(py, 0, rectArea.height - d);

    attachChipToPool(ch);
    resolveOverlaps(null);
    chipState.chips.forEach(applyChipTransform);
    chipState.dragMeta[ch.id] = null;

    scheduleCommitChipPoolPos();
    return;
  }

  const meta = chipState.dragMeta[ch.id] || {};
  const back = meta.lastWallPos || { x: meta.startX ?? ch.x, y: meta.startY ?? ch.y };
  ch.x = back.x;
  ch.y = back.y;

  attachChipToPool(ch);
  resolveOverlaps(null);
  chipState.chips.forEach(applyChipTransform);

  chipState.dragMeta[ch.id] = null;
  scheduleCommitChipPoolPos();
}

/* =========================
   ★ チッププール描画
   ========================= */
function renderChipPool(playerCount){
  if (joinBox.classList.contains('hidden')) chipPool.classList.remove('hidden');

  setChipDFromTag();

  const n = Math.max(0, Number(playerCount || 0));

  if (!n){
    chipPoolArea.innerHTML = '';
    chipState = { ...chipState, builtFor: null, chips: [], draggingId: null, dragMeta:{}, press:null, lastTap:{} };
    return;
  }

  const needRebuild = (chipState.builtFor !== n);
  if (!needRebuild && chipState.chips.length){
    applyChipPoolPosFromState();

    const hasAnyPos = state.chipPoolPos && Object.keys(state.chipPoolPos).length > 0;
    if (!hasAnyPos){
      layoutChipPositions(chipState.chips);
      chipState.chips.forEach(ch => {
        if (ch.id !== chipState.draggingId) applyChipTransform(ch);
      });
      resolveOverlaps(null);
      chipState.chips.forEach(ch => {
        if (ch.id !== chipState.draggingId) applyChipTransform(ch);
      });
      if (state.isHost) scheduleCommitChipPoolPos();
    }

    applyChipOwnersToPool();
    applyChipFacesToPool();
    return;
  }

  chipState.builtFor = n;
  chipState.draggingId = null;
  chipState.dragMeta = {};
  chipState.press = null;
  chipState.lastTap = {};
  chipPoolArea.innerHTML = '';

  const chips = buildChipSetForPlayers(n);

  const hasAnyPos = state.chipPoolPos && Object.keys(state.chipPoolPos).length > 0;

  if (hasAnyPos){
    const rect = chipPoolArea.getBoundingClientRect();
    const d = getChipD();
    const W = rect.width, H = rect.height;
    chips.forEach(ch => {
      const p = state.chipPoolPos[ch.id];
      if (p && Number.isFinite(Number(p.x)) && Number.isFinite(Number(p.y))){
        ch.x = clamp(Number(p.x), 0, Math.max(0, W - d));
        ch.y = clamp(Number(p.y), 0, Math.max(0, H - d));
      }
    });
    const missing = chips.filter(ch => !state.chipPoolPos[ch.id]);
    if (missing.length){
      layoutChipPositions(missing);
    }
  } else {
    layoutChipPositions(chips);
  }

  chips.forEach(ch => {
    chipUid++;
    const el = document.createElement('div');
    el.className = 'chip-item';
    el.dataset.chipId = ch.id;

    ch.faceDown = !!state.chipFaceDown?.[ch.id];
    el.innerHTML = chipSVG(ch.color, ch.stars, chipUid, ch.faceDown);

    ch.el = el;
    applyChipTransform(ch);

    el.addEventListener('pointerdown', (e) => onChipPointerDown(e, ch.id), { passive:false });

    chipPoolArea.appendChild(el);
  });

  chipState.chips = chips;

  if (!hasAnyPos){
    resolveOverlaps(null);
    chipState.chips.forEach(applyChipTransform);
    if (state.isHost) scheduleCommitChipPoolPos();
  }

  applyChipOwnersToPool();
  applyChipFacesToPool();
}

/* =========================
   ★ 52枚デッキ・カード
   ========================= */
function buildDeck52(){
  const suits = [{ s: "♠" },{ s: "♥" },{ s: "♦" },{ s: "♣" }];
  const ranks = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const deck = [];
  for (const su of suits){
    for (const r of ranks) deck.push(`${su.s}${r}`);
  }
  return deck;
}
function shuffleInPlace(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function parseCard(code){
  if (!code || typeof code !== 'string') return null;
  const suit = code.slice(0,1);
  const rank = code.slice(1);
  const isRed = (suit === '♥' || suit === '♦');
  return { suit, rank, isRed };
}
function pipToPercent(row, col){
  const rows = 5, cols = 3;
  const x = (col + 0.5) / cols * 100;
  const y = (row + 0.5) / rows * 100;
  return { x, y };
}
const PIP_LAYOUT = {
  2: [[0,1],[4,1]],
  3: [[0,1],[2,1],[4,1]],
  4: [[0,0],[0,2],[4,0],[4,2]],
  5: [[0,0],[0,2],[2,1],[4,0],[4,2]],
  6: [[0,0],[0,2],[2,0],[2,2],[4,0],[4,2]],
  7: [[0,0],[0,2],[0,1],[2,0],[2,2],[4,0],[4,2]],
  8: [[0,0],[0,2],[1,1],[2,0],[2,2],[3,1],[4,0],[4,2]],
  9: [[0,0],[0,2],[1,1],[2,0],[2,2],[2,1],[3,1],[4,0],[4,2]],
  10:[[0,0],[0,2],[1,1],[1,0],[1,2],[3,0],[3,2],[3,1],[4,0],[4,2]]
};
function createCardElement(code){
  const c = parseCard(code);
  if (!c) return document.createElement('div');

  const el = document.createElement('div');
  el.className = `pcard ${c.isRed ? 'red' : 'black'}`;
  el.dataset.rank = c.rank;
  el.dataset.suit = c.suit;

  const cornerTL = document.createElement('div');
  cornerTL.className = 'corner tl';
  cornerTL.innerHTML = `<div class="rank">${c.rank}</div><div class="suit">${c.suit}</div>`;

  const cornerBR = document.createElement('div');
  cornerBR.className = 'corner br';
  cornerBR.innerHTML = `<div class="rank">${c.rank}</div><div class="suit">${c.suit}</div>`;

  el.appendChild(cornerTL);
  el.appendChild(cornerBR);

  const rankNum = (c.rank === 'A') ? 1 : Number(c.rank);
  const isFace = (c.rank === 'J' || c.rank === 'Q' || c.rank === 'K');

  const pips = document.createElement('div');
  pips.className = 'pips';

  if (isFace){
    const face = document.createElement('div');
    face.className = 'face-holder';
    face.textContent = c.rank;

    const fs = document.createElement('div');
    fs.className = 'face-suit';
    fs.textContent = c.suit;

    el.appendChild(face);
    el.appendChild(fs);
  } else {
    if (c.rank === 'A'){
      const {x,y} = pipToPercent(2,1);
      const pip = document.createElement('div');
      pip.className = 'pip';
      pip.style.left = `${x}%`;
      pip.style.top  = `${y}%`;
      pip.textContent = c.suit;
      pips.appendChild(pip);
    } else {
      const layout = PIP_LAYOUT[rankNum] || [];
      layout.forEach(([r, col]) => {
        const {x,y} = pipToPercent(r,col);
        const pip = document.createElement('div');
        pip.className = 'pip' + (r >= 3 ? ' flip' : '');
        pip.style.left = `${x}%`;
        pip.style.top  = `${y}%`;
        pip.textContent = c.suit;
        pips.appendChild(pip);
      });
    }
    el.appendChild(pips);
  }
  return el;
}
function createBackCardElement(){
  const el = document.createElement('div');
  el.className = 'backcard';
  return el;
}

/* =========================
   ★ デッキ表示
   ========================= */
const STACK_MAX = 15;
const STACK_OFFSETS = [
  {x:0.0,y:0.0,r: 0.0},{x:0.4,y:0.5,r:-0.3},{x:0.9,y:0.9,r: 0.2},{x:1.2,y:1.5,r:-0.4},
  {x:1.8,y:1.9,r: 0.5},{x:2.2,y:2.5,r:-0.2},{x:2.8,y:2.9,r: 0.4},{x:3.1,y:3.6,r:-0.6},
  {x:3.7,y:4.0,r: 0.3},{x:4.2,y:4.6,r:-0.3},{x:4.8,y:5.0,r: 0.6},{x:5.2,y:5.7,r:-0.4},
  {x:5.8,y:6.1,r: 0.4},{x:6.2,y:6.8,r:-0.2},{x:6.8,y:7.2,r: 0.2},
];
function calcStackLayers(deckLen){
  const removed = 52 - deckLen;
  const layers = STACK_MAX - Math.floor(removed / 2);
  return Math.max(1, Math.min(STACK_MAX, layers));
}
function renderDeckVisual(deckStackEl, deckLen, started){
  const shownLen = started ? deckLen : 52;

  deckStackEl.classList.toggle('empty', started && shownLen === 0);

  const countEl = deckStackEl.querySelector('#deckCount');
  deckStackEl.querySelectorAll('.deck-layer').forEach(n => n.remove());

  const layers = (started && shownLen === 0) ? 0 : calcStackLayers(shownLen);
  for (let i = layers - 1; i >= 0; i--){
    const layer = document.createElement('div');
    layer.className = 'deck-layer';
    const o = STACK_OFFSETS[i] || {x:0,y:0,r:0};
    layer.style.transform = `translate(${o.x}px, ${o.y}px) rotate(${o.r}deg)`;
    deckStackEl.insertBefore(layer, countEl);
  }

  if (countEl) countEl.textContent = String(shownLen);
}

function getBoardCodes(){
  const g = state.game || {};
  const codes = Array.isArray(g.boardCodes) ? g.boardCodes : (Array.isArray(g.board) ? g.board : []);
  return codes.filter(Boolean);
}
function getBoardFaceUpCount(){
  const g = state.game || {};
  const n = Number(g.boardFaceUpCount || 0);
  return Number.isFinite(n) ? n : 0;
}
function attachCenterInteractions(){
  const deckStackEl = playerCircle.querySelector('#deckStack');
  if (deckStackEl && !deckStackEl.dataset.bound){
    deckStackEl.dataset.bound = '1';
    deckStackEl.addEventListener('click', onDeckClick);
  }
  const boardRowEl = playerCircle.querySelector('#boardRow');
  if (boardRowEl && !boardRowEl.dataset.bound){
    boardRowEl.dataset.bound = '1';
    boardRowEl.addEventListener('click', onBoardClick);
  }
}
function renderCenterBoard(){
  const deckStackEl = playerCircle.querySelector('#deckStack');
  const boardRowEl  = playerCircle.querySelector('#boardRow');
  if (!deckStackEl || !boardRowEl) return;

  attachCenterInteractions();

  const started = !!state.game?.started;
  const deck = Array.isArray(state.game?.deck) ? state.game.deck : [];
  const boardCodes = started ? getBoardCodes() : [];
  const faceUpCount = started ? Math.min(getBoardFaceUpCount(), boardCodes.length) : 0;

  renderDeckVisual(deckStackEl, started ? deck.length : 52, started);

  const slots = boardRowEl.querySelectorAll('.board-slot');
  slots.forEach((slot, i) => {
    slot.innerHTML = '';
    slot.classList.remove('has-card');

    if (!started) return;

    if (i < boardCodes.length){
      slot.classList.add('has-card');
      if (i < faceUpCount){
        const cardEl = createCardElement(boardCodes[i]);
        slot.appendChild(cardEl);
      } else {
        const back = createBackCardElement();
        slot.appendChild(back);
      }
    }
  });
}

/* =========================
   ★ 配布アニメ
   ========================= */
function getDealSeenKey(){
  return state.roomCode ? `dealSeen_${state.roomCode}` : `dealSeen_unknown`;
}
function getShownCount(pid){
  if (state.dealing && state.dealShownCounts && typeof state.dealShownCounts[pid] === 'number'){
    return state.dealShownCounts[pid];
  }
  const handData = state.hands[pid];
  return (handData && Array.isArray(handData.cards)) ? handData.cards.length : 0;
}
async function waitForTags(order){
  for (let i=0; i<40; i++){
    const ok = order.every(pid => document.querySelector(`.player-wrap[data-pid="${pid}"]`));
    if (ok) return true;
    await sleep(50);
  }
  return false;
}
async function animateOneFly(startX, startY, endX, endY, extraRot=0){
  const el = document.createElement('div');
  el.className = 'fly-card';
  el.style.left = '0px';
  el.style.top  = '0px';
  document.body.appendChild(el);

  const halfW = 30, halfH = 45;
  const sx = startX - halfW, sy = startY - halfH;
  const ex = endX - halfW,   ey = endY - halfH;
  const mx = (sx + ex) / 2;
  const my = (sy + ey) / 2 - 60;

  const anim = el.animate([
    { transform:`translate(${sx}px, ${sy}px) rotate(${0+extraRot}deg) scale(1)` },
    { transform:`translate(${mx}px, ${my}px) rotate(${2+extraRot}deg) scale(1.02)` },
    { transform:`translate(${ex}px, ${ey}px) rotate(${0+extraRot}deg) scale(1)` },
  ], {
    duration: 380,
    easing: 'cubic-bezier(.22,.84,.44,1)',
    fill: 'forwards'
  });

  await anim.finished.catch(()=>{});
  el.remove();
}
async function runDealAnimation(order){
  if (isDealAnimating) return;
  isDealAnimating = true;

  state.dealShownCounts = {};
  order.forEach(pid => state.dealShownCounts[pid] = 0);

  state.dealing = true;
  renderHands();

  try{
    const deckEl = document.getElementById('deckStack');
    if (!deckEl) return;

    const d = deckEl.getBoundingClientRect();
    const startX = d.left + d.width/2;
    const startY = d.top  + d.height/2;

    for (let round=0; round<2; round++){
      for (let i=0; i<order.length; i++){
        const pid = order[i];
        const wrap = document.querySelector(`.player-wrap[data-pid="${pid}"]`);
        if (!wrap) continue;

        const tr = wrap.getBoundingClientRect();
        const endX = tr.left + 10;
        const endY = tr.top + tr.height/2 + 18;

        await animateOneFly(startX, startY, endX, endY, (i%2===0? -1: 1));

        state.dealShownCounts[pid] = (state.dealShownCounts[pid] ?? 0) + 1;
        renderHands();

        await sleep(70);
      }
      await sleep(140);
    }
  } finally {
    state.dealing = false;
    state.dealShownCounts = null;
    isDealAnimating = false;
    renderHands();
  }
}
async function maybePlayDealFromGame(){
  const started = !!state.game?.started;
  const deal = state.game?.deal;
  if (!started || !deal || !deal.id || !Array.isArray(deal.order)) return;

  const at = typeof deal.at === 'number' ? deal.at : deal.id;
  if (Date.now() - at > 20000) {
    sessionStorage.setItem(getDealSeenKey(), String(deal.id));
    return;
  }

  const seen = sessionStorage.getItem(getDealSeenKey());
  if (seen === String(deal.id)) return;

  sessionStorage.setItem(getDealSeenKey(), String(deal.id));

  const ok = await waitForTags(deal.order);
  if (!ok) return;

  await runDealAnimation(deal.order);
}

/* =========================
   ★ 山札/場札クリック（ホスト）
   ========================= */
async function onDeckClick(e){
  e.preventDefault();
  e.stopPropagation();
  if (!state.isHost) return;
  if (!state.roomCode) return;

  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  const snap = await get(gameRef);
  const g = snap.val() || { started:false, deck:[], boardCodes:[], boardFaceUpCount:0 };

  if (!g.started) return;

  const deck = Array.isArray(g.deck) ? [...g.deck] : [];
  const boardCodes = Array.isArray(g.boardCodes) ? [...g.boardCodes] : [];
  const faceUpCount = Number(g.boardFaceUpCount || 0);

  if (boardCodes.length === 0){
    if (deck.length < 3) return;
    const drawn = deck.splice(0, 3);
    await update(gameRef, {
      deck,
      boardCodes: drawn,
      boardFaceUpCount: 0
    });
    return;
  }

  const allFaceUp = (faceUpCount >= boardCodes.length);
  if (allFaceUp && boardCodes.length < 5){
    if (deck.length < 1) return;
    const c = deck.shift();
    boardCodes.push(c);
    await update(gameRef, {
      deck,
      boardCodes,
      boardFaceUpCount: boardCodes.length
    });
  }
}
async function onBoardClick(e){
  e.preventDefault();
  e.stopPropagation();
  if (!state.isHost) return;
  if (!state.roomCode) return;

  const slot = e.target.closest('.board-slot');
  if (!slot) return;

  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  const snap = await get(gameRef);
  const g = snap.val() || { started:false, deck:[], boardCodes:[], boardFaceUpCount:0 };

  if (!g.started) return;

  const boardCodes = Array.isArray(g.boardCodes) ? [...g.boardCodes] : [];
  const faceUpCount = Number(g.boardFaceUpCount || 0);

  if (boardCodes.length === 0) return;
  if (faceUpCount >= boardCodes.length) return;

  await update(gameRef, {
    boardFaceUpCount: Math.min(boardCodes.length, faceUpCount + 1)
  });
}

/* =========================
   subscribe
   ========================= */
function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();

    if (joinBox.classList.contains('hidden')){
      const n = Number(state.room.maxPlayers || 0);
      renderChipPool(n);
    }

    if (state.isHost) maybeStartRevealPhaseIfReady();
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();

    if (state.isHost) maybeStartRevealPhaseIfReady();
  });
}
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
  });
}
function subscribeGame(){
  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  onValue(gameRef, snap => {
    const v = snap.val();
    const base = { started:false, deck:[], boardCodes:[], boardFaceUpCount:0, deal:null };
    state.game = v ? { ...base, ...v } : base;
    renderCenterBoard();
    maybePlayDealFromGame();
  });
}
function subscribeChipOwners(){
  const ownersRef = ref(db, `rooms/${state.roomCode}/chipOwners`);
  onValue(ownersRef, snap => {
    state.chipOwners = snap.val() || {};
    applyChipOwnersToPool();
    renderOwnedChips();
    updateOwnCircleToFit();

    if (state.isHost) maybeStartRevealPhaseIfReady();
  });
}
function subscribeChipPoolPos(){
  const posRef = ref(db, `rooms/${state.roomCode}/chipPoolPos`);
  onValue(posRef, snap => {
    state.chipPoolPos = snap.val() || {};
    applyChipPoolPosFromState();
  });
}
function subscribeChipFaceDown(){
  const fdRef = ref(db, `rooms/${state.roomCode}/chipFaceDown`);
  onValue(fdRef, snap => {
    state.chipFaceDown = snap.val() || {};
    applyChipFacesToPool();
    renderOwnedChips();
  });
}
function subscribeReveal(){
  const rRef = ref(db, `rooms/${state.roomCode}/reveal`);
  onValue(rRef, snap => {
    state.reveal = snap.val() || null;
    renderHands();
  });
}

/* =========================
   ★ 手札描画
   ========================= */
function renderMyHand(){
  myHandEl.innerHTML = '';

  const myId = state.userId;
  const handData = state.hands[myId];
  const finalCards = (handData && Array.isArray(handData.cards)) ? handData.cards : [];

  const shownCount = getShownCount(myId);

  for (let i=0; i<shownCount; i++){
    const wrap = document.createElement('div');
    wrap.className = 'my-card';

    const code = finalCards[i];
    const cardEl = code ? createCardElement(code) : createBackCardElement();
    wrap.appendChild(cardEl);
    myHandEl.appendChild(wrap);
  }
}
function renderHands(){
  renderMyHand();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);
}

const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribeGame();
  subscribeChipOwners();
  subscribeChipPoolPos();
  subscribeChipFaceDown();
  subscribeReveal();

  syncSeatUI();
  renderCenterBoard();

  chipPool.classList.remove('hidden');
  renderChipPool(Number(state.room?.maxPlayers || 0));
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='リンクコピー';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');

          renderChipPool(i);
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    renderPlayerCircle(players);

    setChipDFromTag();
    const n = Number(state.room?.maxPlayers || 0);
    if (joinBox.classList.contains('hidden')) renderChipPool(n);
  });
}

function renderPlayerCircle(players){
  playerCircle.innerHTML = '';
  if (!players.length) return;

  const center = document.createElement('div');
  center.className = 'center-table';
  center.id = 'centerTable';
  center.innerHTML = `
    <div id="deckStack" class="deck-stack empty" title="山札">
      <div id="deckCount" class="deck-count">52</div>
    </div>
    <div id="boardRow" class="board-row" aria-label="場札">
      <div class="board-slot" data-slot="0"></div>
      <div class="board-slot" data-slot="1"></div>
      <div class="board-slot" data-slot="2"></div>
      <div class="board-slot" data-slot="3"></div>
      <div class="board-slot" data-slot="4"></div>
    </div>
  `;
  playerCircle.appendChild(center);

  const n = players.length;
  const radius = 45;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);

  const curRevealPid = getRevealCurrentPid();
  const revealedMap = state.reveal?.revealed || {};

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    const wrap = document.createElement('div');
    wrap.className = 'player-wrap';
    wrap.style.left = `${x}%`;
    wrap.style.top = `${y}%`;
    wrap.dataset.pid = p.id;

    /* ★変更：他プレイヤーだけ「wrapごと」外側＆上へ（チップもタグ横のまま） */
    {
      const circleRect = playerCircle.getBoundingClientRect();
      const scale = (circleRect.width || 260) / 260;
      const out = 35 * scale;
      const up  = 35 * scale;

      const dx = Math.cos(angle);
      const dy = Math.sin(angle);

      if (p.id !== state.userId){
        wrap.style.transform = `translate(-50%,-50%) translate(${Math.round(dx*out)}px, ${Math.round(dy*out - up)}px)`;
      } else {
        wrap.style.transform = `translate(-50%,-50%)`;
      }
    }

    if (p.id === state.userId){
      const oc = document.createElement('div');
      oc.id = 'ownCircle';
      oc.className = 'owncircle' + (state.ownCircleVisible ? '' : ' hidden');
      wrap.appendChild(oc);
    }

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (p.id === state.userId ? ' me' : '');
    tag.textContent = p.name;

    if (curRevealPid && p.id === curRevealPid) tag.classList.add('turn');

    tag.onclick = () => {
      if (p.id === state.userId){
        if (isMyRevealTurn()) revealMyHand();
        return;
      }
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      pendingSeatIndexToSteal = p.seatIndex;
      pendingSeatPlayerIdToSteal = p.id;
      kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
      kickDialog.classList.remove('hidden');
    };

    const count = getShownCount(p.id);
    const isRevealed = !!revealedMap?.[p.id];

    /* ★変更：公開済み表示は「自分以外だけ」 */
    if (isRevealed && p.id !== state.userId){
      const rh = document.createElement('div');
      rh.className = 'reveal-hand';

      const cards = (state.hands?.[p.id] && Array.isArray(state.hands[p.id].cards)) ? state.hands[p.id].cards : [];
      cards.forEach(code => {
        const slot = document.createElement('div');
        slot.className = 'reveal-card';
        const el = code ? createCardElement(code) : createBackCardElement();
        slot.appendChild(el);
        rh.appendChild(slot);
      });

      tag.appendChild(rh);
    } else {
      if (p.id !== state.userId && count > 0){
        const miniHand = document.createElement('div');
        miniHand.className = 'mini-hand';

        const spread = 70;
        const base = (count > 1) ? (-spread/2) : 0;

        for (let idx2=0; idx2<count; idx2++){
          const card = document.createElement('div');
          card.className = 'mini-card';
          card.textContent = '';

          const angleDeg = (count > 1) ? base + (spread/(count-1))*idx2 : 0;
          card.style.transform = `translate(-50%,0) rotate(${angleDeg}deg)`;
          card.style.zIndex = String(10 + idx2);
          miniHand.appendChild(card);
        }
        tag.appendChild(miniHand);
      }
    }

    const ownedBox = document.createElement('div');
    ownedBox.className = 'owned-chips';

    wrap.appendChild(tag);
    wrap.appendChild(ownedBox);
    playerCircle.appendChild(wrap);
  });

  renderCenterBoard();
  maybePlayDealFromGame();

  renderOwnedChips();
  applyChipOwnersToPool();
  requestAnimationFrame(updateOwnCircleToFit);
}

kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* =========================
   ★ ゲーム開始（既存維持）
   ========================= */
async function ensureGameExistsIfHost(){
  if (!state.isHost || !state.roomCode) return;
  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  const snap = await get(gameRef);
  const cur = snap.val();
  const ok =
    cur &&
    typeof cur.started === 'boolean' &&
    Array.isArray(cur.deck) &&
    (Array.isArray(cur.boardCodes) || Array.isArray(cur.board)) &&
    (typeof cur.boardFaceUpCount === 'number' || typeof cur.boardFaceUpCount === 'undefined');
  if (!ok){
    await set(gameRef, { started:false, deck: [], boardCodes: [], boardFaceUpCount: 0, deal:null });
  }
}

async function startGameDeal(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const seated = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? {
      seatIndex: Number(seatIndex),
      id: t.playerId,
      name: t.playerName || '名無し'
    } : null))
    .filter(Boolean)
    .sort((a,b) => a.seatIndex - b.seatIndex);

  const deck = shuffleInPlace(buildDeck52());

  const boardCodes = [];
  const boardFaceUpCount = 0;

  const hands = {};
  seated.forEach(p => hands[p.id] = { cards: [] });

  for (let round=0; round<2; round++){
    for (const p of seated){
      const c = deck.shift();
      if (c) hands[p.id].cards.push(c);
    }
  }

  const deal = {
    id: Date.now(),
    at: Date.now(),
    order: seated.map(p => p.id)
  };

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    set(ref(db, `${base}/game`), { started:true, deck, boardCodes, boardFaceUpCount, deal }),
    set(ref(db, `${base}/hands`), hands),
  ]);
}

hostSettingsBtn.addEventListener('click', async () => {
  if (!state.isHost) return;
  await ensureGameExistsIfHost();
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  await startGameDeal();
  startPop.classList.add('hidden');
});

btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/game`)),
    remove(ref(db, `${base}/chipOwners`)),
    remove(ref(db, `${base}/chipPoolPos`)),
    remove(ref(db, `${base}/chipFaceDown`)),
    remove(ref(db, `${base}/reveal`)),
  ]);

  state.seatedTable = null;
  startPop.classList.add('hidden');
  await syncSeatUI();

  state.game = { started:false, deck:[], boardCodes:[], boardFaceUpCount:0, deal:null };
  renderCenterBoard();

  state.reveal = null;
  renderChipPool(0);
});

window.addEventListener('load', () => {
  renderCenterBoard();
});
</script>

</body>
</html>
